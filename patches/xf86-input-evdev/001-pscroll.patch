Add high precision scroll event support

From: Max Schwarz <Max@x-quadraht.de>

See https://github.com/x-quadraht/pscroll for details
---
 include/evdev-properties.h |    2 +
 man/evdev.man              |    5 +
 src/emuWheel.c             |   51 ++++++++++++++-
 src/evdev.c                |  148 ++++++++++++++++++++++++++++++++------------
 src/evdev.h                |    5 +
 5 files changed, 166 insertions(+), 45 deletions(-)

diff --git a/include/evdev-properties.h b/include/evdev-properties.h
index 7df2876..215908f 100644
--- a/include/evdev-properties.h
+++ b/include/evdev-properties.h
@@ -45,6 +45,8 @@
 #define EVDEV_PROP_WHEEL_TIMEOUT "Evdev Wheel Emulation Timeout"
 /* CARD8, value range 0-32, 0 to always scroll */
 #define EVDEV_PROP_WHEEL_BUTTON "Evdev Wheel Emulation Button"
+/* CARD32 */
+#define EVDEV_PROP_WHEEL_RESOLUTION "Evdev Wheel Emulation Valuator Resolution"
 
 /* Drag lock */
 /* CARD8, either 1 value or pairs, value range 0-32, 0 to disable a value*/
diff --git a/man/evdev.man b/man/evdev.man
index adb3f8d..d84981b 100644
--- a/man/evdev.man
+++ b/man/evdev.man
@@ -133,6 +133,11 @@ must be pressed before wheel emulation is started. If the
 is released before this timeout, the original button press/release event
 is sent.  Default: 200. Property: "Evdev Wheel Emulation Timeout".
 .TP 7
+.BI "Option \*qEmulateWheelResolution\*q \*q" integer \*q
+Specifies the reported resolution of the emulated wheel axes (determines
+the scrolling speed, since events are sent in hardware units).
+Default: 42. Property: "Evdev Wheel Emulation Valuator Resolution".
+.TP 7
 .BI "Option \*qGrabDevice\*q \*q" boolean \*q
 Force a grab on the event device. Doing so will ensure that no other driver
 can initialise the same device and it will also stop the device from sending
diff --git a/src/emuWheel.c b/src/emuWheel.c
index 9a53211..9ab31cb 100644
--- a/src/emuWheel.c
+++ b/src/emuWheel.c
@@ -45,11 +45,12 @@
 #define WHEEL_NOT_CONFIGURED 0
 
 #ifdef HAVE_PROPERTIES
-static Atom prop_wheel_emu      = 0;
-static Atom prop_wheel_axismap  = 0;
-static Atom prop_wheel_inertia  = 0;
-static Atom prop_wheel_timeout  = 0;
-static Atom prop_wheel_button   = 0;
+static Atom prop_wheel_emu        = 0;
+static Atom prop_wheel_axismap    = 0;
+static Atom prop_wheel_inertia    = 0;
+static Atom prop_wheel_timeout    = 0;
+static Atom prop_wheel_button     = 0;
+static Atom prop_wheel_resolution = 0;
 #endif
 
 /* Local Funciton Prototypes */
@@ -186,6 +187,9 @@ EvdevWheelEmuInertia(InputInfoPtr pInfo, WheelAxisPtr axis, int value)
 	inertia = pEvdev->emulateWheel.inertia;
     }
 
+    /* Produce valuator events */
+    EvdevInjectRelativeMotion(pInfo, axis->code, -value);
+
     /* Produce button press events for wheel motion */
     while(abs(axis->traveled_distance) > pEvdev->emulateWheel.inertia) {
 	axis->traveled_distance -= inertia;
@@ -300,6 +304,17 @@ EvdevWheelEmuPreInit(InputInfoPtr pInfo)
     }
 
     pEvdev->emulateWheel.timeout = timeout;
+    
+    pEvdev->emulateWheel.resolution = xf86SetIntOption(pInfo->options,
+                   "EmulateWheelResolution", 42);
+
+    if(pEvdev->emulateWheel.resolution <= 0) {
+        xf86Msg(X_WARNING, "%s: Invalid EmulateWheelResolution value: %d\n",
+                pInfo->name, pEvdev->emulateWheel.resolution);
+        pEvdev->emulateWheel.resolution = 42;
+        xf86Msg(X_WARNING, "%s: Using built-in resolution value %d.\n",
+                pInfo->name, pEvdev->emulateWheel.resolution);
+    }
 
     /* Configure the Y axis or default it */
     if (!EvdevWheelEmuHandleButtonMap(pInfo, &(pEvdev->emulateWheel.Y),
@@ -329,6 +344,10 @@ EvdevWheelEmuPreInit(InputInfoPtr pInfo)
     pEvdev->emulateWheel.X.traveled_distance = 0;
     pEvdev->emulateWheel.Y.traveled_distance = 0;
 
+    /* Valuator to post events to */
+    pEvdev->emulateWheel.X.code = REL_HWHEEL;
+    pEvdev->emulateWheel.Y.code = REL_WHEEL;
+
     xf86Msg(X_CONFIG, "%s: EmulateWheelButton: %d, "
             "EmulateWheelInertia: %d, "
             "EmulateWheelTimeout: %d\n",
@@ -418,6 +437,16 @@ EvdevWheelEmuSetProperty(DeviceIntPtr dev, Atom atom, XIPropertyValuePtr val,
 
         if (!checkonly)
             pEvdev->emulateWheel.timeout = timeout;
+    } else if (atom == prop_wheel_resolution)
+    {
+        if(val->format != 32 || val->type != XA_INTEGER || val->size != 1)
+            return BadMatch;
+
+        if(!checkonly)
+        {
+            pEvdev->emulateWheel.resolution = *((CARD32*)val->data);
+            EvdevSetWheelResolution(dev, pEvdev->emulateWheel.resolution);
+        }
     }
     return Success;
 }
@@ -483,6 +512,18 @@ EvdevWheelEmuInitProperty(DeviceIntPtr dev)
 
     XISetDevicePropertyDeletable(dev, prop_wheel_button, FALSE);
 
+    prop_wheel_resolution = MakeAtom(EVDEV_PROP_WHEEL_RESOLUTION,
+                                    strlen(EVDEV_PROP_WHEEL_RESOLUTION), TRUE);
+
+    rc = XIChangeDeviceProperty(dev, prop_wheel_resolution, XA_INTEGER, 16,
+                                PropModeReplace, 1, &pEvdev->emulateWheel.resolution,
+                                FALSE);
+
+    if (rc != Success)
+        return;
+
+    XISetDevicePropertyDeletable(dev, prop_wheel_resolution, FALSE);
+
     XIRegisterPropertyHandler(dev, EvdevWheelEmuSetProperty, NULL, NULL);
 }
 #endif
diff --git a/src/evdev.c b/src/evdev.c
index 040cfdc..7350da6 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -368,6 +368,17 @@ EvdevQueueButtonClicks(InputInfoPtr pInfo, int button, int count)
     }
 }
 
+/**
+ * Inject a relative motion delta for later event posting
+ */
+void
+EvdevInjectRelativeMotion(InputInfoPtr pInfo, int axis, int amount)
+{
+    EvdevPtr pEvdev = pInfo->private;
+    pEvdev->delta[axis] += amount;
+    pEvdev->rel_queued = 1;
+}
+
 #define ABS_X_VALUE 0x1
 #define ABS_Y_VALUE 0x2
 #define ABS_VALUE   0x4
@@ -587,37 +598,37 @@ EvdevProcessRelativeMotionEvent(InputInfoPtr pInfo, struct input_event *ev)
 
     /* Get the signed value, earlier kernels had this as unsigned */
     value = ev->value;
+    
+    if(ev->code == REL_WHEEL) {
+        if (value > 0)
+            EvdevQueueButtonClicks(pInfo, wheel_up_button, value);
+        else if (value < 0)
+            EvdevQueueButtonClicks(pInfo, wheel_down_button, -value);
 
-    switch (ev->code) {
-        case REL_WHEEL:
-            if (value > 0)
-                EvdevQueueButtonClicks(pInfo, wheel_up_button, value);
-            else if (value < 0)
-                EvdevQueueButtonClicks(pInfo, wheel_down_button, -value);
-            break;
+        /* Keep in sync with wheel emulation events */
+        value *= pEvdev->emulateWheel.resolution;
+    }
 
-        case REL_DIAL:
-        case REL_HWHEEL:
-            if (value > 0)
-                EvdevQueueButtonClicks(pInfo, wheel_right_button, value);
-            else if (value < 0)
-                EvdevQueueButtonClicks(pInfo, wheel_left_button, -value);
-            break;
+    if(ev->code == REL_DIAL || ev->code == REL_HWHEEL) {
+        if (value > 0)
+            EvdevQueueButtonClicks(pInfo, wheel_right_button, value);
+        else if (value < 0)
+            EvdevQueueButtonClicks(pInfo, wheel_left_button, -value);
 
-        /* We don't post wheel events as axis motion. */
-        default:
-            /* Ignore EV_REL events if we never set up for them. */
-            if (!(pEvdev->flags & EVDEV_RELATIVE_EVENTS))
-                return;
+        /* Keep in sync with wheel emulation events */
+        value *= pEvdev->emulateWheel.resolution;
+    }
+
+    /* Ignore EV_REL events if we never set up for them. */
+    if (!(pEvdev->flags & EVDEV_RELATIVE_EVENTS))
+        return;
 
-            /* Handle mouse wheel emulation */
-            if (EvdevWheelEmuFilterMotion(pInfo, ev))
-                return;
+    /* Handle mouse wheel emulation */
+    if (EvdevWheelEmuFilterMotion(pInfo, ev))
+        return;
 
-            pEvdev->rel_queued = 1;
-            pEvdev->delta[ev->code] += value;
-            break;
-    }
+    pEvdev->rel_queued = 1;
+    pEvdev->delta[ev->code] += value;
 }
 
 /**
@@ -883,6 +894,7 @@ EvdevReadInput(InputInfoPtr pInfo)
 }
 
 #define TestBit(bit, array) ((array[(bit) / LONG_BITS]) & (1L << ((bit) % LONG_BITS)))
+#define evdev_SetBit(bit, array)  ((array[(bit) / LONG_BITS]) |= (1L << ((bit) % LONG_BITS)))
 
 static void
 EvdevPtrCtrlProc(DeviceIntPtr device, PtrCtrl *ctrl)
@@ -1390,19 +1402,21 @@ EvdevAddRelClass(DeviceIntPtr device)
     if (!TestBit(EV_REL, pEvdev->bitmask))
         return !Success;
 
+    /* If scroll emulation is turned on, enable
+     * REL_WHEEL and REL_HWHEEL axes even if the
+     * device doesn't support them */
+    if(pEvdev->emulateWheel.enabled)
+    {
+        if(pEvdev->emulateWheel.Y.up_button)
+            evdev_SetBit(REL_WHEEL, pEvdev->rel_bitmask);
+        if(pEvdev->emulateWheel.X.up_button)
+            evdev_SetBit(REL_HWHEEL, pEvdev->rel_bitmask);
+    }
+
     num_axes = EvdevCountBits(pEvdev->rel_bitmask, NLONGS(REL_MAX));
     if (num_axes < 1)
         return !Success;
 
-    /* Wheels are special, we post them as button events. So let's ignore them
-     * in the axes list too */
-    if (TestBit(REL_WHEEL, pEvdev->rel_bitmask))
-        num_axes--;
-    if (TestBit(REL_HWHEEL, pEvdev->rel_bitmask))
-        num_axes--;
-    if (TestBit(REL_DIAL, pEvdev->rel_bitmask))
-        num_axes--;
-
     if (num_axes <= 0)
         return !Success;
 
@@ -1418,9 +1432,7 @@ EvdevAddRelClass(DeviceIntPtr device)
     for (axis = REL_X; i < MAX_VALUATORS && axis <= REL_MAX; axis++)
     {
         pEvdev->axis_map[axis] = -1;
-        /* We don't post wheel events, so ignore them here too */
-        if (axis == REL_WHEEL || axis == REL_HWHEEL || axis == REL_DIAL)
-            continue;
+
         if (!TestBit(axis, pEvdev->rel_bitmask))
             continue;
         pEvdev->axis_map[axis] = i;
@@ -1445,19 +1457,29 @@ EvdevAddRelClass(DeviceIntPtr device)
     for (axis = REL_X; axis <= REL_MAX; axis++)
     {
         int axnum = pEvdev->axis_map[axis];
+        int resolution = 1;
+        int no_integration = 0;
 
         if (axnum == -1)
             continue;
+
+        if(axis == REL_WHEEL || axis == REL_HWHEEL || axis == REL_DIAL)
+        {
+            resolution = pEvdev->emulateWheel.resolution;
+            no_integration = 1;
+        }
+
         xf86InitValuatorAxisStruct(device, axnum,
 #if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
                 atoms[axnum],
 #endif
-                -1, -1, 1, 0, 1
+                -1, -1, resolution, 0, resolution
 #if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
                                    , Relative
 #endif
                 );
         xf86InitValuatorDefaults(device, axnum);
+        xf86SetValuatorAxisNoIntegration(device, axnum, no_integration);
     }
 
     free(atoms);
@@ -1795,6 +1817,15 @@ EvdevCacheCompare(InputInfoPtr pInfo, BOOL compare)
         goto error;
     }
 
+    // If wheel emulation is enabled, we provide wheel valuators
+    if(pEvdev->emulateWheel.enabled)
+    {
+        if(pEvdev->emulateWheel.Y.up_button)
+            evdev_SetBit(REL_WHEEL, rel_bitmask);
+        if(pEvdev->emulateWheel.X.up_button)
+            evdev_SetBit(REL_HWHEEL, rel_bitmask);
+    }
+
     if (!compare) {
         memcpy(pEvdev->rel_bitmask, rel_bitmask, len);
     } else if (memcmp(pEvdev->rel_bitmask, rel_bitmask, len)) {
@@ -2219,7 +2250,6 @@ EvdevPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
         return pInfo;
     }
 
-
     xf86DeleteInput(pInfo, 0);
     return NULL;
 }
@@ -2704,6 +2734,44 @@ EvdevInitProperty(DeviceIntPtr dev)
 
 }
 
+void
+EvdevSetWheelResolution(DeviceIntPtr dev, int resolution)
+{
+    InputInfoPtr pInfo  = dev->public.devicePrivate;
+    EvdevPtr     pEvdev = pInfo->private;
+    int axnum;
+    
+    axnum = pEvdev->axis_map[REL_WHEEL];
+    if(axnum != -1)
+    {
+        xf86InitValuatorAxisStruct(dev, axnum,
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
+                XIGetKnownProperty(rel_labels[REL_WHEEL]),
+#endif
+                -1, -1, resolution, 0, resolution
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
+                                   , Relative
+#endif
+                );
+        xf86SetValuatorAxisNoIntegration(dev, axnum, 1);
+    }
+
+    axnum = pEvdev->axis_map[REL_HWHEEL];
+    if(axnum != -1)
+    {
+        xf86InitValuatorAxisStruct(dev, axnum,
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
+                XIGetKnownProperty(rel_labels[REL_HWHEEL]),
+#endif
+                -1, -1, resolution, 0, resolution
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
+                                   , Relative
+#endif
+                );
+        xf86SetValuatorAxisNoIntegration(dev, axnum, 1);
+    }
+}
+
 static int
 EvdevSetProperty(DeviceIntPtr dev, Atom atom, XIPropertyValuePtr val,
                  BOOL checkonly)
diff --git a/src/evdev.h b/src/evdev.h
index 7c17ca4..dee5da4 100644
--- a/src/evdev.h
+++ b/src/evdev.h
@@ -102,6 +102,7 @@ typedef struct {
     int up_button;
     int down_button;
     int traveled_distance;
+    int code;
 } WheelAxis, *WheelAxisPtr;
 
 /* Event queue used to defer keyboard/button events until EV_SYN time. */
@@ -165,6 +166,7 @@ typedef struct {
         WheelAxis           Y;
         Time                expires;     /* time of expiry */
         Time                timeout;
+        int                 resolution;
     } emulateWheel;
     /* run-time calibration */
     struct {
@@ -209,6 +211,9 @@ void EvdevPostAbsoluteMotionEvents(InputInfoPtr pInfo, int num_v, int first_v,
 				   int v[MAX_VALUATORS]);
 unsigned int EvdevUtilButtonEventToButtonNumber(EvdevPtr pEvdev, int code);
 
+void EvdevInjectRelativeMotion(InputInfoPtr pInfo, int axis, int amount);
+void EvdevSetWheelResolution(DeviceIntPtr dev, int resolution);
+
 /* Middle Button emulation */
 int  EvdevMBEmuTimer(InputInfoPtr);
 BOOL EvdevMBEmuFilterEvent(InputInfoPtr, int, BOOL);
