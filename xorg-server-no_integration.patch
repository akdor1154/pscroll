diff --git a/Xext/saver.c b/Xext/saver.c
index 04e6497..1f54a2c 100644
--- a/Xext/saver.c
+++ b/Xext/saver.c
@@ -618,10 +618,10 @@ CreateSaverWindow (ScreenPtr pScreen)
     	    	FreeResource (pWin->drawable.id, RT_NONE);
     	    	return FALSE;
 	    }
+	pAttr->pCursor->refcnt++;
 	if (pWin->optional->cursor)
 	    FreeCursor (pWin->optional->cursor, (Cursor)0);
 	pWin->optional->cursor = pAttr->pCursor;
-	pAttr->pCursor->refcnt++;
 	pWin->cursorIsNone = FALSE;
 	CheckWindowOptionalNeed (pWin);
 	mask |= CWCursor;
diff --git a/Xext/security.c b/Xext/security.c
index 2cd0e17..ff5c1d1 100644
--- a/Xext/security.c
+++ b/Xext/security.c
@@ -280,11 +280,13 @@ SecurityComputeAuthorizationTimeout(
      * 32 bits worth of milliseconds
      */
     CARD32 maxSecs = (CARD32)(~0) / (CARD32)MILLI_PER_SECOND;
+    CARD32 nowSec = GetTimeInMillis()/ (CARD32)MILLI_PER_SECOND;
 
-    if (seconds > maxSecs)
-    { /* only come here if we want to wait more than 49 days */
-	pAuth->secondsRemaining = seconds - maxSecs;
-	return maxSecs * MILLI_PER_SECOND;
+    CARD32 maxPossibleSec = maxSecs - nowSec;
+    if (seconds > maxPossibleSec -1 )
+    {
+	pAuth->secondsRemaining = seconds - maxPossibleSec;
+	return maxPossibleSec * MILLI_PER_SECOND;
     }
     else
     { /* by far the common case */
diff --git a/Xi/exevents.c b/Xi/exevents.c
index e680f6f..38893d2 100644
--- a/Xi/exevents.c
+++ b/Xi/exevents.c
@@ -1167,6 +1167,25 @@ InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval, int
     ax->min_resolution = min_res;
     ax->max_resolution = max_res;
     ax->label = label;
+    ax->no_integration = 0;
+}
+
+/**
+ * Prevents axis from being integrated in dix/getevents.c
+ */
+void
+SetValuatorAxisNoIntegration(DeviceIntPtr dev, int axnum, Bool no_integration)
+{
+    AxisInfoPtr ax;
+
+    if (!dev || !dev->valuator)
+        return;
+    if (axnum >= dev->valuator->numAxes)
+        return;
+
+    ax = dev->valuator->axes + axnum;
+    
+    ax->no_integration = no_integration;
 }
 
 static void
diff --git a/Xi/stubs.c b/Xi/stubs.c
index 400e937..817238a 100644
--- a/Xi/stubs.c
+++ b/Xi/stubs.c
@@ -232,6 +232,13 @@ NewInputDeviceRequest(InputOption *options, DeviceIntPtr *pdev)
     return BadValue;
 }
 
+int
+NewInputDeviceRequest18(InputOption *options, InputAttributes *attrs,
+                      DeviceIntPtr *pdev)
+{
+    return BadValue;
+}
+
 /****************************************************************************
  *
  * Caller: configRemoveDevice (and others)
diff --git a/config/Makefile.am b/config/Makefile.am
index 7fa2df8..27f251b 100644
--- a/config/Makefile.am
+++ b/config/Makefile.am
@@ -1,12 +1,20 @@
-AM_CFLAGS = @DIX_CFLAGS@
+AM_CFLAGS = $(DIX_CFLAGS)
 
 noinst_LTLIBRARIES = libconfig.la
 libconfig_la_SOURCES = config.c config-backends.h
 
+if CONFIG_UDEV
+
+AM_CFLAGS += $(UDEV_CFLAGS)
+libconfig_la_SOURCES += udev.c
+libconfig_la_LIBADD = $(UDEV_LIBS)
+
+else
+
 if CONFIG_NEED_DBUS
-AM_CFLAGS += @DBUS_CFLAGS@
+AM_CFLAGS += $(DBUS_CFLAGS)
 libconfig_la_SOURCES += dbus-core.c
-endif
+libconfig_la_LIBADD = $(DBUS_LIBS)
 
 if CONFIG_DBUS_API
 dbusconfigdir = $(sysconfdir)/dbus-1/system.d
@@ -16,7 +24,13 @@ libconfig_la_SOURCES += dbus.c
 endif
 
 if CONFIG_HAL
+AM_CFLAGS += $(HAL_CFLAGS)
 libconfig_la_SOURCES += hal.c
+libconfig_la_LIBADD += $(HAL_LIBS)
 endif
 
+endif # CONFIG_NEED_DBUS
+
+endif # !CONFIG_UDEV
+
 EXTRA_DIST = xorg-server.conf x11-input.fdi
diff --git a/config/config-backends.h b/config/config-backends.h
index 907e86b..0a2a22a 100644
--- a/config/config-backends.h
+++ b/config/config-backends.h
@@ -26,8 +26,18 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "input.h"
 
-#ifdef CONFIG_NEED_DBUS
+void remove_devices(const char *backend, const char *config_info);
+BOOL device_is_duplicate(const char *config_info);
+void add_option(InputOption **options, const char *key, const char *value);
+
+#ifdef CONFIG_UDEV
+int config_udev_init(void);
+void config_udev_fini(void);
+#else
+
+# ifdef CONFIG_NEED_DBUS
 #include <dbus/dbus.h>
 
 typedef void (*config_dbus_core_connect_hook)(DBusConnection *connection,
@@ -46,14 +56,15 @@ int config_dbus_core_init(void);
 void config_dbus_core_fini(void);
 int config_dbus_core_add_hook(struct config_dbus_core_hook *hook);
 void config_dbus_core_remove_hook(struct config_dbus_core_hook *hook);
-#endif
+# endif
 
-#ifdef CONFIG_DBUS_API
+# ifdef CONFIG_DBUS_API
 int config_dbus_init(void);
 void config_dbus_fini(void);
-#endif
+# endif
 
-#ifdef CONFIG_HAL
+# ifdef CONFIG_HAL
 int config_hal_init(void);
 void config_hal_fini(void);
+# endif
 #endif
diff --git a/config/config.c b/config/config.c
index b013293..7bf5e41 100644
--- a/config/config.c
+++ b/config/config.c
@@ -28,13 +28,17 @@
 #endif
 
 #include "os.h"
+#include "inputstr.h"
 #include "hotplug.h"
 #include "config-backends.h"
 
 void
 config_init(void)
 {
-#if defined(CONFIG_DBUS_API) || defined(CONFIG_HAL)
+#ifdef CONFIG_UDEV
+    if (!config_udev_init())
+        ErrorF("[config] failed to initialise udev\n");
+#elif defined(CONFIG_NEED_DBUS)
     if (config_dbus_core_init()) {
 # ifdef CONFIG_DBUS_API
        if (!config_dbus_init())
@@ -54,7 +58,9 @@ config_init(void)
 void
 config_fini(void)
 {
-#if defined(CONFIG_DBUS_API) || defined(CONFIG_HAL)
+#if defined(CONFIG_UDEV)
+    config_udev_fini();
+#elif defined(CONFIG_NEED_DBUS)
 # ifdef CONFIG_HAL
     config_hal_fini();
 # endif
@@ -64,3 +70,70 @@ config_fini(void)
     config_dbus_core_fini();
 #endif
 }
+
+static void
+remove_device(const char *backend, DeviceIntPtr dev)
+{
+    /* this only gets called for devices that have already been added */
+    LogMessage(X_INFO, "config/%s: removing device %s\n", backend, dev->name);
+
+    /* Call PIE here so we don't try to dereference a device that's
+     * already been removed. */
+    OsBlockSignals();
+    ProcessInputEvents();
+    DeleteInputDeviceRequest(dev);
+    OsReleaseSignals();
+}
+
+void
+remove_devices(const char *backend, const char *config_info)
+{
+    DeviceIntPtr dev, next;
+
+    for (dev = inputInfo.devices; dev; dev = next) {
+        next = dev->next;
+        if (dev->config_info && strcmp(dev->config_info, config_info) == 0)
+            remove_device(backend, dev);
+    }
+    for (dev = inputInfo.off_devices; dev; dev = next) {
+        next = dev->next;
+        if (dev->config_info && strcmp(dev->config_info, config_info) == 0)
+            remove_device(backend, dev);
+    }
+}
+
+BOOL
+device_is_duplicate(const char *config_info)
+{
+    DeviceIntPtr dev;
+
+    for (dev = inputInfo.devices; dev; dev = dev->next)
+    {
+        if (dev->config_info && (strcmp(dev->config_info, config_info) == 0))
+            return TRUE;
+    }
+
+    for (dev = inputInfo.off_devices; dev; dev = dev->next)
+    {
+        if (dev->config_info && (strcmp(dev->config_info, config_info) == 0))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+void
+add_option(InputOption **options, const char *key, const char *value)
+{
+    if (!value || *value == '\0')
+        return;
+
+    for (; *options; options = &(*options)->next)
+        ;
+    *options = xcalloc(sizeof(**options), 1);
+    if (!*options) /* Yeesh. */
+        return;
+    (*options)->key = xstrdup(key);
+    (*options)->value = xstrdup(value);
+    (*options)->next = NULL;
+}
diff --git a/config/dbus.c b/config/dbus.c
index 37462ac..a255808 100644
--- a/config/dbus.c
+++ b/config/dbus.c
@@ -147,7 +147,7 @@ add_device(DBusMessage *message, DBusMessage *reply, DBusError *error)
         dbus_message_iter_next(&iter);
     }
 
-    ret = NewInputDeviceRequest(options, &dev);
+    ret = NewInputDeviceRequest18(options, NULL, &dev);
     if (ret != Success) {
         DebugF("[config/dbus] NewInputDeviceRequest failed\n");
         goto unwind;
diff --git a/config/hal.c b/config/hal.c
index 28f55a0..b0dc670 100644
--- a/config/hal.c
+++ b/config/hal.c
@@ -58,25 +58,9 @@ struct xkb_options {
     char* options;
 };
 
-
-static void
-remove_device(DeviceIntPtr dev)
-{
-    /* this only gets called for devices that have already been added */
-    LogMessage(X_INFO, "config/hal: removing device %s\n", dev->name);
-
-    /* Call PIE here so we don't try to dereference a device that's
-     * already been removed. */
-    OsBlockSignals();
-    ProcessInputEvents();
-    DeleteInputDeviceRequest(dev);
-    OsReleaseSignals();
-}
-
 static void
 device_removed(LibHalContext *ctx, const char *udi)
 {
-    DeviceIntPtr dev, next;
     char *value;
 
     value = xalloc(strlen(udi) + 5); /* "hal:" + NULL */
@@ -84,36 +68,11 @@ device_removed(LibHalContext *ctx, const char *udi)
         return;
     sprintf(value, "hal:%s", udi);
 
-    for (dev = inputInfo.devices; dev; dev = next) {
-	next = dev->next;
-        if (dev->config_info && strcmp(dev->config_info, value) == 0)
-            remove_device(dev);
-    }
-    for (dev = inputInfo.off_devices; dev; dev = next) {
-	next = dev->next;
-        if (dev->config_info && strcmp(dev->config_info, value) == 0)
-            remove_device(dev);
-    }
+    remove_devices("hal", value);
 
     xfree(value);
 }
 
-static void
-add_option(InputOption **options, const char *key, const char *value)
-{
-    if (!value || *value == '\0')
-        return;
-
-    for (; *options; options = &(*options)->next)
-        ;
-    *options = xcalloc(sizeof(**options), 1);
-    if (!*options) /* Yeesh. */
-        return;
-    (*options)->key = xstrdup(key);
-    (*options)->value = xstrdup(value);
-    (*options)->next = NULL;
-}
-
 static char *
 get_prop_string(LibHalContext *hal_ctx, const char *udi, const char *name)
 {
@@ -166,31 +125,12 @@ get_prop_string_array(LibHalContext *hal_ctx, const char *udi, const char *prop)
     return ret;
 }
 
-static BOOL
-device_is_duplicate(char *config_info)
-{
-    DeviceIntPtr dev;
-
-    for (dev = inputInfo.devices; dev; dev = dev->next)
-    {
-        if (dev->config_info && (strcmp(dev->config_info, config_info) == 0))
-            return TRUE;
-    }
-
-    for (dev = inputInfo.off_devices; dev; dev = dev->next)
-    {
-        if (dev->config_info && (strcmp(dev->config_info, config_info) == 0))
-            return TRUE;
-    }
-
-    return FALSE;
-}
-
 static void
 device_added(LibHalContext *hal_ctx, const char *udi)
 {
     char *path = NULL, *driver = NULL, *name = NULL, *config_info = NULL;
     InputOption *options = NULL, *tmpo = NULL;
+    InputAttributes attrs = {0};
     DeviceIntPtr dev = NULL;
     DBusError error;
     struct xkb_options xkb_opts = {0};
@@ -215,10 +155,29 @@ device_added(LibHalContext *hal_ctx, const char *udi)
         LogMessage(X_WARNING,"config/hal: no driver or path specified for %s\n", udi);
         goto unwind;
     }
+    attrs.device = xstrdup(path);
 
     name = get_prop_string(hal_ctx, udi, "info.product");
     if (!name)
         name = xstrdup("(unnamed)");
+    else
+        attrs.product = xstrdup(name);
+
+    attrs.vendor = get_prop_string(hal_ctx, udi, "info.vendor");
+    attrs.tags = xstrtokenize(get_prop_string(hal_ctx, udi, "input.tags"), ",");
+
+    if (libhal_device_query_capability(hal_ctx, udi, "input.keys", NULL))
+        attrs.flags |= ATTR_KEYBOARD;
+    if (libhal_device_query_capability(hal_ctx, udi, "input.mouse", NULL))
+        attrs.flags |= ATTR_POINTER;
+    if (libhal_device_query_capability(hal_ctx, udi, "input.joystick", NULL))
+        attrs.flags |= ATTR_JOYSTICK;
+    if (libhal_device_query_capability(hal_ctx, udi, "input.tablet", NULL))
+        attrs.flags |= ATTR_TABLET;
+    if (libhal_device_query_capability(hal_ctx, udi, "input.touchpad", NULL))
+        attrs.flags |= ATTR_TOUCHPAD;
+    if (libhal_device_query_capability(hal_ctx, udi, "input.touchscreen", NULL))
+        attrs.flags |= ATTR_TOUCHSCREEN;
 
     options = xcalloc(sizeof(*options), 1);
     if (!options){
@@ -400,7 +359,7 @@ device_added(LibHalContext *hal_ctx, const char *udi)
 
     /* this isn't an error, but how else do you output something that the user can see? */
     LogMessage(X_INFO, "config/hal: Adding input device %s\n", name);
-    if ((rc = NewInputDeviceRequest(options, &dev)) != Success) {
+    if ((rc = NewInputDeviceRequest18(options, &attrs, &dev)) != Success) {
         LogMessage(X_ERROR, "config/hal: NewInputDeviceRequest failed (%d)\n", rc);
         dev = NULL;
         goto unwind;
@@ -430,6 +389,18 @@ unwind:
         xfree(tmpo);
     }
 
+    xfree(attrs.product);
+    xfree(attrs.vendor);
+    xfree(attrs.device);
+    if (attrs.tags) {
+        char **tag = attrs.tags;
+        while (*tag) {
+            xfree(*tag);
+            tag++;
+        }
+        xfree(attrs.tags);
+    }
+
     if (xkb_opts.layout)
         xfree(xkb_opts.layout);
     if (xkb_opts.rules)
diff --git a/config/udev.c b/config/udev.c
new file mode 100644
index 0000000..a5e5d14
--- /dev/null
+++ b/config/udev.c
@@ -0,0 +1,269 @@
+/*
+ * Copyright © 2009 Julien Cristau
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Julien Cristau <jcristau@debian.org>
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <libudev.h>
+
+#include "input.h"
+#include "inputstr.h"
+#include "hotplug.h"
+#include "config-backends.h"
+#include "os.h"
+
+#define UDEV_XKB_PROP_KEY "xkb"
+
+static struct udev_monitor *udev_monitor;
+
+static void
+device_added(struct udev_device *udev_device)
+{
+    const char *path, *name = NULL;
+    char *config_info = NULL;
+    const char *syspath;
+    const char *key, *value, *tmp;
+    InputOption *options = NULL, *tmpo;
+    InputAttributes attrs = {};
+    DeviceIntPtr dev = NULL;
+    struct udev_list_entry *set, *entry;
+    struct udev_device *parent;
+    int rc;
+
+    path = udev_device_get_devnode(udev_device);
+
+    syspath = udev_device_get_syspath(udev_device);
+
+    if (!path || !syspath)
+        return;
+
+    if (!udev_device_get_property_value(udev_device, "ID_INPUT"))
+        return;
+
+    options = xcalloc(sizeof(*options), 1);
+    if (!options)
+        return;
+
+    options->key = xstrdup("_source");
+    options->value = xstrdup("server/udev");
+    if (!options->key || !options->value)
+        goto unwind;
+
+    parent = udev_device_get_parent(udev_device);
+    if (parent) {
+        name = udev_device_get_sysattr_value(parent, "name");
+        if (!name)
+            name = udev_device_get_property_value(parent, "NAME");
+    }
+    if (!name)
+        name = "(unnamed)";
+    else
+        attrs.product = name;
+    add_option(&options, "name", name);
+
+    add_option(&options, "path", path);
+    add_option(&options, "device", path);
+    attrs.device = path;
+    attrs.tags = xstrtokenize(udev_device_get_property_value(udev_device, "ID_INPUT.tags"), ",");
+
+    config_info = Xprintf("udev:%s", syspath);
+    if (!config_info)
+        goto unwind;
+
+    if (device_is_duplicate(config_info)) {
+        LogMessage(X_WARNING, "config/udev: device %s already added. "
+                              "Ignoring.\n", name);
+        goto unwind;
+    }
+
+    set = udev_device_get_properties_list_entry(udev_device);
+    udev_list_entry_foreach(entry, set) {
+        key = udev_list_entry_get_name(entry);
+        if (!key)
+            continue;
+        value = udev_list_entry_get_value(entry);
+        if (!strncasecmp(key, UDEV_XKB_PROP_KEY,
+                                sizeof(UDEV_XKB_PROP_KEY) - 1)) {
+            tmp = key + sizeof(UDEV_XKB_PROP_KEY) - 1;
+            if (!strcasecmp(tmp, "rules"))
+                add_option(&options, "xkb_rules", value);
+            else if (!strcasecmp(tmp, "layout"))
+                add_option(&options, "xkb_layout", value);
+            else if (!strcasecmp(tmp, "variant"))
+                add_option(&options, "xkb_variant", value);
+            else if (!strcasecmp(tmp, "model"))
+                add_option(&options, "xkb_model", value);
+            else if (!strcasecmp(tmp, "options"))
+                add_option(&options, "xkb_options", value);
+        } else if (!strcmp(key, "x11_driver")) {
+            add_option(&options, "driver", value);
+        } else if (!strcmp(key, "ID_VENDOR")) {
+            attrs.vendor = value;
+        } else if (!strcmp(key, "ID_INPUT_KEY")) {
+            attrs.flags |= ATTR_KEYBOARD;
+        } else if (!strcmp(key, "ID_INPUT_MOUSE")) {
+            attrs.flags |= ATTR_POINTER;
+        } else if (!strcmp(key, "ID_INPUT_JOYSTICK")) {
+            attrs.flags |= ATTR_JOYSTICK;
+        } else if (!strcmp(key, "ID_INPUT_TABLET")) {
+            attrs.flags |= ATTR_TABLET;
+        } else if (!strcmp(key, "ID_INPUT_TOUCHPAD")) {
+            attrs.flags |= ATTR_TOUCHPAD;
+        } else if (!strcmp(key, "ID_INPUT_TOUCHSCREEN")) {
+            attrs.flags |= ATTR_TOUCHSCREEN;
+        }
+    }
+    LogMessage(X_INFO, "config/udev: Adding input device %s (%s)\n",
+               name, path);
+    rc = NewInputDeviceRequest18(options, &attrs, &dev);
+    if (rc != Success)
+        goto unwind;
+
+    for (; dev; dev = dev->next) {
+        xfree(dev->config_info);
+        dev->config_info = xstrdup(config_info);
+    }
+
+ unwind:
+    xfree(config_info);
+    while (!dev && (tmpo = options)) {
+        options = tmpo->next;
+        xfree(tmpo->key);
+        xfree(tmpo->value);
+        xfree(tmpo);
+    }
+
+    if (attrs.tags) {
+        char **tag = attrs.tags;
+        while (*tag) {
+            xfree(*tag);
+            tag++;
+        }
+        xfree(attrs.tags);
+    }
+
+    return;
+}
+
+static void
+device_removed(struct udev_device *device)
+{
+    char *value;
+    const char *syspath = udev_device_get_syspath(device);
+
+    value = Xprintf("udev:%s", syspath);
+    if (!value)
+        return;
+
+    remove_devices("udev", value);
+
+    xfree(value);
+}
+
+static void
+wakeup_handler(pointer data, int err, pointer read_mask)
+{
+    int udev_fd = udev_monitor_get_fd(udev_monitor);
+    struct udev_device *udev_device;
+    const char *action;
+
+    if (err < 0)
+        return;
+
+    if (FD_ISSET(udev_fd, (fd_set *)read_mask)) {
+        udev_device = udev_monitor_receive_device(udev_monitor);
+        if (!udev_device)
+            return;
+        action = udev_device_get_action(udev_device);
+        if (action) {
+            if (!strcmp(action, "add"))
+                device_added(udev_device);
+            else if (!strcmp(action, "remove"))
+                device_removed(udev_device);
+        }
+        udev_device_unref(udev_device);
+    }
+}
+
+static void
+block_handler(pointer data, struct timeval **tv, pointer read_mask)
+{
+}
+
+int
+config_udev_init(void)
+{
+    struct udev *udev;
+    struct udev_enumerate *enumerate;
+    struct udev_list_entry *devices, *device;
+
+    udev = udev_new();
+    if (!udev)
+        return 0;
+    udev_monitor = udev_monitor_new_from_netlink(udev, "udev");
+    if (!udev_monitor)
+        return 0;
+
+    if (udev_monitor_enable_receiving(udev_monitor)) {
+        ErrorF("config/udev: failed to bind the udev monitor\n");
+        return 0;
+    }
+
+    enumerate = udev_enumerate_new(udev);
+    if (!enumerate)
+        return 0;
+    udev_enumerate_scan_devices(enumerate);
+    devices = udev_enumerate_get_list_entry(enumerate);
+    udev_list_entry_foreach(device, devices) {
+        const char *syspath = udev_list_entry_get_name(device);
+        struct udev_device *udev_device = udev_device_new_from_syspath(udev, syspath);
+        device_added(udev_device);
+        udev_device_unref(udev_device);
+    }
+    udev_enumerate_unref(enumerate);
+
+    RegisterBlockAndWakeupHandlers(block_handler, wakeup_handler, NULL);
+    AddGeneralSocket(udev_monitor_get_fd(udev_monitor));
+
+    return 1;
+}
+
+void
+config_udev_fini(void)
+{
+    struct udev *udev;
+
+    if (!udev_monitor)
+        return;
+
+    udev = udev_monitor_get_udev(udev_monitor);
+
+    RemoveGeneralSocket(udev_monitor_get_fd(udev_monitor));
+    RemoveBlockAndWakeupHandlers(block_handler, wakeup_handler, udev_monitor);
+    udev_monitor_unref(udev_monitor);
+    udev_monitor = NULL;
+    udev_unref(udev);
+}
diff --git a/configure.ac b/configure.ac
index 4a19ae4..d7f2516 100644
--- a/configure.ac
+++ b/configure.ac
@@ -119,7 +119,7 @@ AM_CONDITIONAL(SPECIAL_DTRACE_OBJECTS, [test "x$SPECIAL_DTRACE_OBJECTS" = "xyes"
 
 AC_HEADER_DIRENT
 AC_HEADER_STDC
-AC_CHECK_HEADERS([fcntl.h stdlib.h string.h unistd.h dlfcn.h stropts.h])
+AC_CHECK_HEADERS([fcntl.h stdlib.h string.h unistd.h dlfcn.h stropts.h fnmatch.h])
 
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_C_CONST
@@ -471,6 +471,10 @@ AC_ARG_WITH(module-dir,      AS_HELP_STRING([--with-module-dir=DIR],
 				  [Directory where modules are installed (default: $libdir/xorg/modules)]),
 				[ moduledir="$withval" ],
 				[ moduledir="${libdir}/xorg/modules" ])
+AC_ARG_WITH(extra-module-dir,AS_HELP_STRING([--with-extra-module-dir=DIR],
+				  [Extra module directory to search for modules before the default one (default: empty)]),
+				[ extra_moduledir="$withval" ],
+				[ extra_moduledir="" ])
 AC_ARG_WITH(log-dir,         AS_HELP_STRING([--with-log-dir=DIR],
 				  [Directory where log files are kept (default: $localstatedir/log)]),
 				[ logdir="$withval" ],
@@ -502,9 +506,9 @@ AC_ARG_WITH(default-font-path, AS_HELP_STRING([--with-default-font-path=PATH], [
 AC_ARG_WITH(xkb-path,         AS_HELP_STRING([--with-xkb-path=PATH], [Path to XKB base dir (default: ${datadir}/X11/xkb)]),
 				[ XKBPATH="$withval" ],
 				[ XKBPATH="${datadir}/X11/xkb" ])
-AC_ARG_WITH(xkb-output,       AS_HELP_STRING([--with-xkb-output=PATH], [Path to XKB output dir (default: ${datadir}/X11/xkb/compiled)]),
+AC_ARG_WITH(xkb-output,       AS_HELP_STRING([--with-xkb-output=PATH], [Path to XKB output dir (default: ${localstatedir}/cache/xkb)]),
 				[ XKBOUTPUT="$withval" ],
-				[ XKBOUTPUT="compiled" ])
+				[ XKBOUTPUT="${localstatedir}/cache/xkb" ])
 AC_ARG_WITH(default-xkb-rules, AS_HELP_STRING([--with-default-xkb-rules=RULES],
                                    [Keyboard ruleset (default: base/evdev)]),
                                 [ XKB_DFLT_RULES="$withval" ],
@@ -601,6 +605,7 @@ AC_ARG_ENABLE(multibuffer,    AS_HELP_STRING([--enable-multibuffer], [Build Mult
 AC_ARG_ENABLE(dbe,            AS_HELP_STRING([--disable-dbe], [Build DBE extension (default: enabled)]), [DBE=$enableval], [DBE=yes])
 AC_ARG_ENABLE(xf86bigfont,    AS_HELP_STRING([--disable-xf86bigfont], [Build XF86 Big Font extension (default: disabled)]), [XF86BIGFONT=$enableval], [XF86BIGFONT=no])
 AC_ARG_ENABLE(dpms,           AS_HELP_STRING([--disable-dpms], [Build DPMS extension (default: enabled)]), [DPMSExtension=$enableval], [DPMSExtension=yes])
+AC_ARG_ENABLE(config-udev,    AS_HELP_STRING([--enable-config-udev], [Build udev support (default: no)]), [CONFIG_UDEV=$enableval], [CONFIG_UDEV=no])
 AC_ARG_ENABLE(config-dbus,    AS_HELP_STRING([--enable-config-dbus], [Build D-BUS API support (default: no)]), [CONFIG_DBUS_API=$enableval], [CONFIG_DBUS_API=no])
 AC_ARG_ENABLE(config-hal,     AS_HELP_STRING([--disable-config-hal], [Build HAL support (default: auto)]), [CONFIG_HAL=$enableval], [CONFIG_HAL=auto])
 AC_ARG_ENABLE(xfree86-utils,     AS_HELP_STRING([--enable-xfree86-utils], [Build xfree86 DDX utilities (default: enabled)]), [XF86UTILS=$enableval], [XF86UTILS=yes])
@@ -760,6 +765,26 @@ LIBXTST="xtst >= 1.0.99.2"
 LIBPCIACCESS="pciaccess >= 0.8.0"
 LIBGLIB="glib-2.0 >= 2.16"
 LIBSELINUX="libselinux >= 2.0.86"
+LIBUDEV="libudev >= 143"
+
+if test "x$CONFIG_UDEV" = xyes &&
+ { test "x$CONFIG_DBUS_API" = xyes || test "x$CONFIG_HAL" = xyes; }; then
+       AC_MSG_ERROR([Hotplugging through both libudev and dbus/hal not allowed])
+fi
+
+PKG_CHECK_MODULES(UDEV, $LIBUDEV, [HAVE_LIBUDEV=yes], [HAVE_LIBUDEV=no])
+if test "x$CONFIG_UDEV" = xauto; then
+       CONFIG_UDEV="$HAVE_LIBUDEV"
+fi
+AM_CONDITIONAL(CONFIG_UDEV, [test "x$CONFIG_UDEV" = xyes])
+if test "x$CONFIG_UDEV" = xyes; then
+       CONFIG_DBUS_API=no
+       CONFIG_HAL=no
+       if ! test "x$HAVE_LIBUDEV" = xyes; then
+               AC_MSG_ERROR([udev configuration API requested, but libudev is not installed])
+       fi
+       AC_DEFINE(CONFIG_UDEV, 1, [Use libudev for input hotplug])
+fi
 
 dnl HAVE_DBUS is true if we actually have the D-Bus library, whereas
 dnl CONFIG_DBUS_API is true if we want to enable the D-Bus config
@@ -793,13 +818,11 @@ if test "x$CONFIG_HAL" = xyes; then
 	fi
 
 	AC_DEFINE(CONFIG_HAL, 1, [Use the HAL hotplug API])
-        REQUIRED_LIBS="$REQUIRED_LIBS hal"
 	CONFIG_NEED_DBUS="yes"
 fi
 AM_CONDITIONAL(CONFIG_HAL, [test "x$CONFIG_HAL" = xyes])
 
 if test "x$CONFIG_NEED_DBUS" = xyes; then
-	REQUIRED_LIBS="$REQUIRED_LIBS dbus-1"
         AC_DEFINE(CONFIG_NEED_DBUS, 1, [Use D-Bus for input hotplug])
 fi
 AM_CONDITIONAL(CONFIG_NEED_DBUS, [test "x$CONFIG_NEED_DBUS" = xyes])
@@ -1100,7 +1123,7 @@ AC_DEFINE_DIR(XKB_BIN_DIRECTORY, XKB_BIN_DIRECTORY, [Path to XKB bin dir])
 dnl Make sure XKM_OUTPUT_DIR is an absolute path
 XKBOUTPUT_FIRSTCHAR=`echo $XKBOUTPUT | cut -b 1`
 if [[ x$XKBOUTPUT_FIRSTCHAR != x/ -a x$XKBOUTPUT_FIRSTCHAR != 'x$' ]] ; then
-   XKBOUTPUT="$XKB_BASE_DIRECTORY/$XKBOUTPUT"
+   AC_MSG_ERROR([xkb-output must be an absolute path.])
 fi
 
 dnl XKM_OUTPUT_DIR (used in code) must end in / or file names get hosed
@@ -1285,26 +1308,66 @@ MIEXT_SHADOW_INC='-I$(top_srcdir)/miext/shadow'
 MIEXT_SHADOW_LIB='$(top_builddir)/miext/shadow/libshadow.la'
 CORE_INCS='-I$(top_srcdir)/include -I$(top_builddir)/include'
 
-# OpenSSL used for SHA1 hashing in render/glyph.c, but we don't need all of
-# the OpenSSL libraries, just libcrypto
-# Some systems have matching functionality in the smaller/simpler libmd
-# Builders who want to force a choice can set SHA1_LIB and SHA1_CFLAGS
-if test "x$SHA1_LIB" = "x" ; then
-  AC_CHECK_LIB([md], [SHA1Init], [SHA1_LIB="-lmd"
-            AC_DEFINE([HAVE_SHA1_IN_LIBMD], [1],
-            [Use libmd SHA1 functions instead of OpenSSL libcrypto])])
+# SHA1 hashing
+AC_ARG_WITH([sha1],
+            [AS_HELP_STRING([--with-sha1=libmd|libgcrypt|libcrypto|libnettle],
+                            [choose SHA1 implementation])])
+AC_CHECK_LIB([md], [SHA1Init], [HAVE_LIBMD=yes])
+if test "x$with_sha1" = x && test "x$HAVE_LIBMD" = xyes; then
+        with_sha1=libmd
+fi
+if test "x$with_sha1" = xlibmd && test "x$HAVE_LIBMD" != xyes; then
+        AC_MSG_ERROR([libmd requested but not found])
+fi
+if test "x$with_sha1" = xlibmd; then
+        AC_DEFINE([HAVE_SHA1_IN_LIBMD], [1],
+                  [Use libmd SHA1 functions])
+        SHA1_LIBS=-lmd
+fi
+AC_CHECK_LIB([gcrypt], [gcry_md_open], [HAVE_LIBGCRYPT=yes])
+if test "x$with_sha1" = x && test "x$HAVE_LIBGCRYPT" = xyes; then
+        with_sha1=libgcrypt
+fi
+if test "x$with_sha1" = xlibgcrypt; then
+        AC_DEFINE([HAVE_SHA1_IN_LIBGCRYPT], [1],
+                  [Use libgcrypt SHA1 functions])
+        SHA1_LIBS=-lgcrypt
+fi
+AC_CHECK_LIB([nettle], [nettle_sha1_init], [HAVE_LIBNETTLE=yes])
+if test "x$with_sha1" = x && test "x$HAVE_LIBNETTLE" = xyes; then
+        with_sha1=libnettle
+fi
+if test "x$with_sha1" = xlibnettle; then
+        AC_DEFINE([HAVE_SHA1_IN_LIBNETTLE], [1],
+                  [Use libnettle SHA1 functions])
+        SHA1_LIBS=/usr/lib/libnettle.a
+fi
+# We don't need all of the OpenSSL libraries, just libcrypto
+AC_CHECK_LIB([crypto], [SHA1_Init], [HAVE_LIBCRYPTO=yes])
+PKG_CHECK_MODULES([OPENSSL], [openssl], [HAVE_OPENSSL_PKC=yes],
+                  [HAVE_OPENSSL_PKC=no])
+if test "x$HAVE_LIBCRYPTO" = xyes || test "x$HAVE_OPENSSL_PKC" = xyes; then
+        if test "x$with_sha1" = x; then
+                with_sha1=libcrypto
+        fi
+else
+        if test "x$with_sha1" = xlibcrypto; then
+                AC_MSG_ERROR([OpenSSL libcrypto requested but not found])
+        fi
 fi
-
-if test "x$SHA1_LIB" = "x" ; then
-  PKG_CHECK_EXISTS([OPENSSL], [openssl], [HAVE_OPENSSL_PKC=yes],
-                    [HAVE_OPENSSL_PKC=no])
-  if test "x$HAVE_OPENSSL_PKC" = xyes; then
-    REQUIRED_LIBS="$REQUIRED_LIBS openssl"
-  else
-    AC_CHECK_LIB([crypto], [SHA1_Init], [SHA1_LIB="-lcrypto"],
-                 [AC_MSG_ERROR([OpenSSL must be installed in order to build the X server.])])
-  fi
+if test "x$with_sha1" = xlibcrypto; then
+        if test "x$HAVE_LIBCRYPTO" = xyes; then
+                SHA1_LIBS=-lcrypto
+        else
+                SHA1_LIBS="$OPENSSL_LIBS"
+                SHA1_CFLAGS="$OPENSSL_CFLAGS"
+        fi
+fi
+if test "x$with_sha1" = x; then
+        AC_MSG_ERROR([No suitable SHA1 implementation found])
 fi
+AC_SUBST(SHA1_LIBS)
+AC_SUBST(SHA1_CFLAGS)
 
 PKG_CHECK_MODULES([XSERVERCFLAGS], [$REQUIRED_MODULES $REQUIRED_LIBS])
 PKG_CHECK_MODULES([XSERVERLIBS], [$REQUIRED_LIBS])
@@ -1326,7 +1389,7 @@ PKG_CHECK_MODULES([XSERVERLIBS], [$REQUIRED_LIBS])
 #
 XSERVER_CFLAGS="${XSERVERCFLAGS_CFLAGS} ${SHA1_CFLAGS}"
 XSERVER_LIBS="$DIX_LIB $CONFIG_LIB $MI_LIB $OS_LIB"
-XSERVER_SYS_LIBS="${XSERVERLIBS_LIBS} ${SYS_LIBS} ${LIBS} ${SHA1_LIB}"
+XSERVER_SYS_LIBS="${XSERVERLIBS_LIBS} ${SYS_LIBS} ${LIBS} ${SHA1_LIBS}"
 AC_SUBST([XSERVER_LIBS])
 AC_SUBST([XSERVER_SYS_LIBS])
 
@@ -1656,6 +1719,7 @@ if test "x$XORG" = xyes; then
 
 	dnl these only go in xorg-config.h
 	XF86CONFIGFILE="xorg.conf"
+	XF86CONFIGDIR="xorg.conf.d"
 	CONFIGFILE="$sysconfdir/$XF86CONFIGFILE"
 	LOGPREFIX="$logdir/Xorg."
 	AC_DEFINE(XORG_SERVER, 1, [Building Xorg server])
@@ -1668,7 +1732,9 @@ if test "x$XORG" = xyes; then
 	AC_DEFINE(__XSERVERNAME__, "Xorg", [Name of X server])
 	AC_DEFINE_DIR(__XCONFIGFILE__, XF86CONFIGFILE, [Name of configuration file])
 	AC_DEFINE_DIR(XF86CONFIGFILE, XF86CONFIGFILE, [Name of configuration file])
+	AC_DEFINE_DIR(__XCONFIGDIR__, XF86CONFIGDIR, [Name of configuration directory])
 	AC_DEFINE_DIR(DEFAULT_MODULE_PATH, moduledir, [Default module search path])
+	AC_DEFINE_DIR(EXTRA_MODULE_PATH, extra_moduledir, [Extra module search path, searched before the default one])
 	AC_DEFINE_DIR(DEFAULT_LIBRARY_PATH, libdir, [Default library install path])
 	AC_DEFINE_DIR(DEFAULT_LOGPREFIX, LOGPREFIX, [Default log location])
 	AC_DEFINE_UNQUOTED(__VENDORDWEBSUPPORT__, ["$VENDOR_WEB"], [Vendor web address for support])
diff --git a/cpprules.in b/cpprules.in
index 7556200..cccda88 100644
--- a/cpprules.in
+++ b/cpprules.in
@@ -36,7 +36,8 @@ MANDEFS = \
 	-D__adminmansuffix__=$(ADMIN_MAN_SUFFIX) \
 	-D__mandir__=$(mandir) \
 	-D__projectroot__=$(prefix) \
-	-D__xconfigfile__=$(__XCONFIGFILE__) -D__xconfigdir__=$(XCONFIGDIR) \
+	-D__xconfigfile__=$(__XCONFIGFILE__) \
+	-D__xconfigdir__=$(__XCONFIGDIR__) \
 	-D__xkbdir__=$(XKB_BASE_DIRECTORY) \
 	-D__modulepath__="$(DEFAULT_MODULE_PATH)" \
 	-D__xlogfile__=$(XLOGFILE) -D__xservername__=$(XSERVERNAME) 
diff --git a/debian/xserver-xorg-core.postinst b/debian/xserver-xorg-core.postinst
new file mode 100644
index 0000000..1651b5a
--- /dev/null
+++ b/debian/xserver-xorg-core.postinst
@@ -0,0 +1,649 @@
+#!/bin/sh
+
+set -e
+
+THIS_PACKAGE=xserver-xorg-core
+THIS_SCRIPT=postinst
+
+# This is the X Strike Force shell library for X Window System package
+# maintainer scripts.  It serves to define shell functions commonly used by
+# such packages, and performs some error checking necessary for proper operation
+# of those functions.  By itself, it does not "do" much; the maintainer scripts
+# invoke the functions defined here to accomplish package installation and
+# removal tasks.
+
+# If you are reading this within a Debian package maintainer script (e.g.,
+# /var/lib/dpkg/info/PACKAGE.{config,preinst,postinst,prerm,postrm}), you can
+# skip past this library by scanning forward in this file to the string
+# "GOBSTOPPER".
+
+SOURCE_VERSION=2:1.7.6-2ubuntu7
+OFFICIAL_BUILD=
+
+# Use special abnormal exit codes so that problems with this library are more
+# easily tracked down.
+SHELL_LIB_INTERNAL_ERROR=86
+SHELL_LIB_THROWN_ERROR=74
+SHELL_LIB_USAGE_ERROR=99
+
+# old -> new variable names
+if [ -z "$DEBUG_XORG_PACKAGE" ] && [ -n "$DEBUG_XFREE86_PACKAGE" ]; then
+  DEBUG_XORG_PACKAGE="$DEBUG_XFREE86_PACKAGE"
+fi
+if [ -z "$DEBUG_XORG_DEBCONF" ] && [ -n "$DEBUG_XFREE86_DEBCONF" ]; then
+  DEBUG_XORG_DEBCONF="$DEBUG_XFREE86_DEBCONF"
+fi
+
+# initial sanity checks
+if [ -z "$THIS_PACKAGE" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_PACKAGE shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of this package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ -z "$THIS_SCRIPT" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_SCRIPT shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of the
+"$THIS_PACKAGE" package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ "$1" = "reconfigure" ] || [ -n "$DEBCONF_RECONFIGURE" ]; then
+  RECONFIGURE="true"
+else
+  RECONFIGURE=
+fi
+
+if ([ "$1" = "install" ] || [ "$1" = "configure" ]) && [ -z "$2" ]; then
+  FIRSTINST="yes"
+fi
+
+if [ -z "$RECONFIGURE" ] && [ -z "$FIRSTINST" ]; then
+  UPGRADE="yes"
+fi
+
+trap "message;\
+      message \"Received signal.  Aborting $THIS_PACKAGE package $THIS_SCRIPT script.\";\
+      message;\
+      exit 1" HUP INT QUIT TERM
+
+reject_nondigits () {
+  # syntax: reject_nondigits [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters other than decimal digits and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain anything but digits?
+    if ! expr "$1" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+      # can't use die(), because it wraps message() which wraps this function
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_nondigits() encountered" \
+           "possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+reject_unlikely_path_chars () {
+  # syntax: reject_unlikely_path_chars [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters unlikely to be seen in a path and which the shell might
+  # interpret and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain any funny characters?
+    if expr "$1" : '.*[!$&()*;<>?|].*' > /dev/null 2>&1; then
+      # can't use die(), because I want to avoid forward references
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_unlikely_path_chars()" \
+           "encountered possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+# Query the terminal to establish a default number of columns to use for
+# displaying messages to the user.  This is used only as a fallback in the
+# event the COLUMNS variable is not set.  ($COLUMNS can react to SIGWINCH while
+# the script is running, and this cannot, only being calculated once.)
+DEFCOLUMNS=$(stty size 2> /dev/null | awk '{print $2}') || true
+if ! expr "$DEFCOLUMNS" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+  DEFCOLUMNS=80
+fi
+
+message () {
+  # pretty-print messages of arbitrary length
+  reject_nondigits "$COLUMNS"
+  echo "$*" | fmt -t -w ${COLUMNS:-$DEFCOLUMNS} >&2
+}
+
+observe () {
+  # syntax: observe message ...
+  #
+  # issue observational message suitable for logging someday when support for
+  # it exists in dpkg
+  if [ -n "$DEBUG_XORG_PACKAGE" ]; then
+    message "$THIS_PACKAGE $THIS_SCRIPT note: $*"
+  fi
+}
+
+warn () {
+  # syntax: warn message ...
+  #
+  # issue warning message suitable for logging someday when support for
+  # it exists in dpkg; also send to standard error
+  message "$THIS_PACKAGE $THIS_SCRIPT warning: $*"
+}
+
+die () {
+  # syntax: die message ...
+  #
+  # exit script with error message
+  message "$THIS_PACKAGE $THIS_SCRIPT error: $*"
+  exit $SHELL_LIB_THROWN_ERROR
+}
+
+internal_error () {
+  # exit script with error; essentially a "THIS SHOULD NEVER HAPPEN" message
+  message "internal error: $*"
+  if [ -n "$OFFICIAL_BUILD" ]; then
+    message "Please report a bug in the $THIS_SCRIPT script of the" \
+            "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+            "Tracking System.  Include all messages above that mention the" \
+            "$THIS_PACKAGE package.  Visit " \
+            "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+            "instructions, read the file" \
+            "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+            "package, or install the reportbug package and use the command of" \
+            "the same name to file a report."
+  fi
+  exit $SHELL_LIB_INTERNAL_ERROR
+}
+
+usage_error () {
+  message "usage error: $*"
+  message "Please report a bug in the $THIS_SCRIPT script of the" \
+          "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+          "Tracking System.  Include all messages above that mention the" \
+          "$THIS_PACKAGE package.  Visit " \
+          "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+          "instructions, read the file" \
+          "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+          "package, or install the reportbug package and use the command of" \
+          "the same name to file a report."
+  exit $SHELL_LIB_USAGE_ERROR
+}
+
+font_update () {
+  # run $UPDATECMDS in $FONTDIRS
+
+  local dir cmd shortcmd x_font_dir_prefix
+
+  x_font_dir_prefix="/usr/share/fonts/X11"
+
+  if [ -z "$UPDATECMDS" ]; then
+    usage_error "font_update() called but \$UPDATECMDS not set"
+  fi
+  if [ -z "$FONTDIRS" ]; then
+    usage_error "font_update() called but \$FONTDIRS not set"
+  fi
+
+  reject_unlikely_path_chars "$UPDATECMDS"
+  reject_unlikely_path_chars "$FONTDIRS"
+
+  for dir in $FONTDIRS; do
+    if [ -d "$x_font_dir_prefix/$dir" ]; then
+      for cmd in $UPDATECMDS; do
+        if which "$cmd" > /dev/null 2>&1; then
+          shortcmd=${cmd##*/}
+          observe "running $shortcmd in $dir font directory"
+	  cmd_opts=
+          if [ "$shortcmd" = "update-fonts-alias" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          if [ "$shortcmd" = "update-fonts-dir" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          if [ "$shortcmd" = "update-fonts-scale" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          $cmd $cmd_opts $dir || warn "$cmd $cmd_opts $dir" \
+                              "failed; font directory data may not" \
+                              "be up to date"
+        else
+          warn "$cmd not found; not updating corresponding $dir font" \
+               "directory data"
+        fi
+      done
+    else
+      warn "$dir is not a directory; not updating font directory data"
+    fi
+  done
+}
+
+remove_conffile_prepare () {
+  # syntax: remove_conffile_prepare filename official_md5sum ...
+  #
+  # Check a conffile "filename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 2 ]; then
+    usage_error "remove_conffile_prepare() called with wrong number of" \
+                "arguments; expected at least 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+  shift
+
+  # does the conffile even exist?
+  if [ -e "$conffile" ]; then
+    # calculate its checksum
+    current_checksum=$(md5sum < "$conffile" | sed 's/[[:space:]].*//')
+    # compare it to each supplied checksum
+    while [ -n "$1" ]; do
+      if [ "$current_checksum" = "$1" ]; then
+        # we found a match; move the confffile and stop looking
+        observe "preparing obsolete conffile $conffile for removal"
+        mv "$conffile" "$conffile.$THIS_PACKAGE-tmp"
+        break
+      fi
+      shift
+    done
+  fi
+}
+
+remove_conffile_lookup () {
+  # syntax: remove_conffile_lookup package filename
+  #
+  # Lookup the md5sum of a conffile in dpkg's database, and prepare for removal
+  # if it matches the actual file's md5sum.
+  #
+  # Call this function when you would call remove_conffile_prepare but only
+  # want to check against dpkg's status database instead of known checksums.
+
+  local package conffile old_md5sum
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "remove_conffile_lookup() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  package="$1"
+  conffile="$2"
+
+  if ! [ -e "$conffile" ]; then
+    return
+  fi
+  old_md5sum="$(dpkg-query -W -f='${Conffiles}' "$package" | \
+    awk '{ if (match($0, "^ '"$conffile"' ")) print $2}')"
+  if [ -n "$old_md5sum" ]; then
+    remove_conffile_prepare "$conffile" "$old_md5sum"
+  fi
+}
+
+remove_conffile_commit () {
+  # syntax: remove_conffile_commit filename
+  #
+  # Complete the removal of a conffile "filename" that has become obsolete.
+  #
+  # Call this function from a postinst script after having used
+  # remove_conffile_prepare() in the preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_commit() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, remove it
+  if [ -e "$conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "committing removal of obsolete conffile $conffile"
+    rm "$conffile.$THIS_PACKAGE-tmp"
+  fi
+}
+
+remove_conffile_rollback () {
+  # syntax: remove_conffile_rollback filename
+  #
+  # Roll back the removal of a conffile "filename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" is  after having used remove_conffile_prepare() in the
+  # preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_rollback() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, move it
+  # back
+  if [ -e "$conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "rolling back removal of obsolete conffile $conffile"
+    mv "$conffile.$THIS_PACKAGE-tmp" "$conffile"
+  fi
+}
+
+replace_conffile_with_symlink_prepare () {
+  # syntax: replace_conffile_with_symlink_prepare oldfilename newfilename \
+  # official_md5sum ...
+  #
+  # Check a conffile "oldfilename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails. Otherwise copy it
+  # to newfilename and let dpkg handle it through conffiles mechanism.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 3 ]; then
+    usage_error "replace_conffile_with_symlink_prepare() called with wrong" \
+                " number of arguments; expected at least 3, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  oldconffile="$1"
+  shift
+  newconffile="$1"
+  shift
+
+  remove_conffile_prepare "$_oldconffile" "$@"
+  # If $oldconffile still exists, then md5sums didn't match.
+  # Copy it to new one.
+  if [ -f "$oldconffile" ]; then
+    cp "$oldconffile" "$newconffile"
+  fi
+
+}
+
+replace_conffile_with_symlink_commit () {
+  # syntax: replace_conffile_with_symlink_commit oldfilename
+  #
+  # Complete the removal of a conffile "oldfilename" that has been
+  # replaced by a symlink.
+  #
+  # Call this function from a postinst script after having used
+  # replace_conffile_with_symlink_prepare() in the preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "replace_conffile_with_symlink_commit() called with wrong" \
+                "number of arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  remove_conffile_commit "$conffile"
+}
+
+replace_conffile_with_symlink_rollback () {
+  # syntax: replace_conffile_with_symlink_rollback oldfilename newfilename
+  #
+  # Roll back the replacing of a conffile "oldfilename" with symlink to
+  # "newfilename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" and verify $2 to ensure the package failed to upgrade
+  # from a version (or install over a version removed-but-not-purged) prior
+  # to the one in which the conffile was obsoleted.
+  # You should have  used replace_conffile_with_symlink_prepare() in the
+  # preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "replace_conffile_with_symlink_rollback() called with wrong" \
+                "number of arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  oldconffile="$1"
+  newconffile="$2"
+
+  remove_conffile_rollback "$_oldconffile"
+  if [ -f "$newconffile" ]; then
+    rm "$newconffile"
+  fi
+}
+
+run () {
+  # syntax: run command [ argument ... ]
+  #
+  # Run specified command with optional arguments and report its exit status.
+  # Useful for commands whose exit status may be nonzero, but still acceptable,
+  # or commands whose failure is not fatal to us.
+  #
+  # NOTE: Do *not* use this function with db_get or db_metaget commands; in
+  # those cases the return value of the debconf command *must* be checked
+  # before the string returned by debconf is used for anything.
+
+  local retval
+
+  # validate arguments
+  if [ $# -lt 1 ]; then
+    usage_error "run() called with wrong number of arguments; expected at" \
+                "least 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  "$@" || retval=$?
+
+  if [ ${retval:-0} -ne 0 ]; then
+    observe "command \"$*\" exited with status $retval"
+  fi
+}
+
+make_symlink_sane () {
+  # syntax: make_symlink_sane symlink target
+  #
+  # Ensure that the symbolic link symlink exists, and points to target.
+  #
+  # If symlink does not exist, create it and point it at target.
+  #
+  # If symlink exists but is not a symbolic link, back it up.
+  #
+  # If symlink exists, is a symbolic link, but points to the wrong location, fix
+  # it.
+  #
+  # If symlink exists, is a symbolic link, and already points to target, do
+  # nothing.
+  #
+  # This function wouldn't be needed if ln had an -I, --idempotent option.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "make_symlink_sane() called with wrong number of arguments;" \
+      "expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local symlink target
+
+  symlink="$1"
+  target="$2"
+
+  if [ -L "$symlink" ] && [ "$(readlink "$symlink")" = "$target" ]; then
+      observe "link from $symlink to $target already exists"
+  else
+    observe "creating symbolic link from $symlink to $target"
+    mkdir -p "${target%/*}" "${symlink%/*}"
+    ln -s -b -S ".dpkg-old" "$target" "$symlink"
+  fi
+}
+
+migrate_dir_to_symlink () {
+  # syntax: migrate_dir_to_symlink old_location new_location
+  #
+  # Per Debian Policy section 6.5.4, "A directory will never be replaced by a
+  # symbolic link to a directory or vice versa; instead, the existing state
+  # (symlink or not) will be left alone and dpkg will follow the symlink if
+  # there is one."
+  #
+  # We have to do it ourselves.
+  #
+  # This function moves the contents of old_location, a directory, into
+  # new_location, a directory, then makes old_location a symbolic link to
+  # new_location.
+  #
+  # old_location need not exist, but if it does, it must be a directory (or a
+  # symlink to a directory).  If it is not, it is backed up.  If new_location
+  # exists already and is not a directory, it is backed up.
+  #
+  # This function should be called from a package's preinst so that other
+  # packages unpacked after this one --- but before this package's postinst runs
+  # --- are unpacked into new_location even if their payloads contain
+  # old_location filespecs.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "migrate_dir_to_symlink() called with wrong number of"
+                "arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local new old
+
+  old="$1"
+  new="$2"
+
+  # Is old location a symlink?
+  if [ -L "$old" ]; then
+    # Does it already point to new location?
+    if [ "$(readlink "$old")" = "$new" ]; then
+      # Nothing to do; migration has already been done.
+      observe "migration of $old to $new already done"
+      return 0
+    else
+      # Back it up.
+      warn "backing up symbolic link $old as $old.dpkg-old"
+      mv -b "$old" "$old.dpkg-old"
+    fi
+  fi
+
+  # Does old location exist, but is not a directory?
+  if [ -e "$old" ] && ! [ -d "$old" ]; then
+      # Back it up.
+      warn "backing up non-directory $old as $old.dpkg-old"
+      mv -b "$old" "$old.dpkg-old"
+  fi
+
+  observe "migrating $old to $new"
+
+  # Is new location a symlink?
+  if [ -L "$new" ]; then
+    # Does it point the wrong way, i.e., back to where we're migrating from?
+    if [ "$(readlink "$new")" = "$old" ]; then
+      # Get rid of it.
+      observe "removing symbolic link $new which points to $old"
+      rm "$new"
+    else
+      # Back it up.
+      warn "backing up symbolic link $new as $new.dpkg-old"
+      mv -b "$new" "$new.dpkg-old"
+    fi
+  fi
+
+  # Does new location exist, but is not a directory?
+  if [ -e "$new" ] && ! [ -d "$new" ]; then
+    warn "backing up non-directory $new as $new.dpkg-old"
+    mv -b "$new" "$new.dpkg-old"
+  fi
+
+  # Create new directory if it does not yet exist.
+  if ! [ -e "$new" ]; then
+    observe "creating $new"
+    mkdir -p "$new"
+  fi
+
+  # Copy files in old location to new location.  Back up any filenames that
+  # already exist in the new location with the extension ".dpkg-old".
+  observe "copying files from $old to $new"
+  if ! (cd "$old" && cp -a -b -S ".dpkg-old" . "$new"); then
+    die "error(s) encountered while copying files from $old to $new"
+  fi
+
+  # Remove files at old location.
+  observe "removing $old"
+  rm -r "$old"
+
+  # Create symlink from old location to new location.
+  make_symlink_sane "$old" "$new"
+}
+
+# vim:set ai et sw=2 ts=2 tw=80:
+
+# GOBSTOPPER: The X Strike Force shell library ends here.
+
+case "$1" in
+  configure)
+  if dpkg --compare-versions "$2" lt-nl 2:1.5.2-1; then
+    remove_conffile_commit /etc/X11/xserver/SecurityPolicy
+    rmdir /etc/X11/xserver 2>/dev/null || true
+  fi
+
+  if dpkg --compare-versions "$2" lt 2:1.7.3.901-2; then
+    if [ `uname -s` = "Linux" ]; then
+      udevadm trigger --subsystem-match=input --action=change
+    fi
+  fi
+esac
+
+#DEBHELPER#
+
+exit 0
+
+# vim:set ai et sw=2 ts=2 tw=80:
diff --git a/debian/xserver-xorg-core.postrm b/debian/xserver-xorg-core.postrm
new file mode 100644
index 0000000..dc2a38e
--- /dev/null
+++ b/debian/xserver-xorg-core.postrm
@@ -0,0 +1,645 @@
+#!/bin/sh
+
+set -e
+
+THIS_PACKAGE=xserver-xorg-core
+THIS_SCRIPT=postrm
+
+# This is the X Strike Force shell library for X Window System package
+# maintainer scripts.  It serves to define shell functions commonly used by
+# such packages, and performs some error checking necessary for proper operation
+# of those functions.  By itself, it does not "do" much; the maintainer scripts
+# invoke the functions defined here to accomplish package installation and
+# removal tasks.
+
+# If you are reading this within a Debian package maintainer script (e.g.,
+# /var/lib/dpkg/info/PACKAGE.{config,preinst,postinst,prerm,postrm}), you can
+# skip past this library by scanning forward in this file to the string
+# "GOBSTOPPER".
+
+SOURCE_VERSION=2:1.7.6-2ubuntu7
+OFFICIAL_BUILD=
+
+# Use special abnormal exit codes so that problems with this library are more
+# easily tracked down.
+SHELL_LIB_INTERNAL_ERROR=86
+SHELL_LIB_THROWN_ERROR=74
+SHELL_LIB_USAGE_ERROR=99
+
+# old -> new variable names
+if [ -z "$DEBUG_XORG_PACKAGE" ] && [ -n "$DEBUG_XFREE86_PACKAGE" ]; then
+  DEBUG_XORG_PACKAGE="$DEBUG_XFREE86_PACKAGE"
+fi
+if [ -z "$DEBUG_XORG_DEBCONF" ] && [ -n "$DEBUG_XFREE86_DEBCONF" ]; then
+  DEBUG_XORG_DEBCONF="$DEBUG_XFREE86_DEBCONF"
+fi
+
+# initial sanity checks
+if [ -z "$THIS_PACKAGE" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_PACKAGE shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of this package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ -z "$THIS_SCRIPT" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_SCRIPT shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of the
+"$THIS_PACKAGE" package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ "$1" = "reconfigure" ] || [ -n "$DEBCONF_RECONFIGURE" ]; then
+  RECONFIGURE="true"
+else
+  RECONFIGURE=
+fi
+
+if ([ "$1" = "install" ] || [ "$1" = "configure" ]) && [ -z "$2" ]; then
+  FIRSTINST="yes"
+fi
+
+if [ -z "$RECONFIGURE" ] && [ -z "$FIRSTINST" ]; then
+  UPGRADE="yes"
+fi
+
+trap "message;\
+      message \"Received signal.  Aborting $THIS_PACKAGE package $THIS_SCRIPT script.\";\
+      message;\
+      exit 1" HUP INT QUIT TERM
+
+reject_nondigits () {
+  # syntax: reject_nondigits [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters other than decimal digits and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain anything but digits?
+    if ! expr "$1" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+      # can't use die(), because it wraps message() which wraps this function
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_nondigits() encountered" \
+           "possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+reject_unlikely_path_chars () {
+  # syntax: reject_unlikely_path_chars [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters unlikely to be seen in a path and which the shell might
+  # interpret and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain any funny characters?
+    if expr "$1" : '.*[!$&()*;<>?|].*' > /dev/null 2>&1; then
+      # can't use die(), because I want to avoid forward references
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_unlikely_path_chars()" \
+           "encountered possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+# Query the terminal to establish a default number of columns to use for
+# displaying messages to the user.  This is used only as a fallback in the
+# event the COLUMNS variable is not set.  ($COLUMNS can react to SIGWINCH while
+# the script is running, and this cannot, only being calculated once.)
+DEFCOLUMNS=$(stty size 2> /dev/null | awk '{print $2}') || true
+if ! expr "$DEFCOLUMNS" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+  DEFCOLUMNS=80
+fi
+
+message () {
+  # pretty-print messages of arbitrary length
+  reject_nondigits "$COLUMNS"
+  echo "$*" | fmt -t -w ${COLUMNS:-$DEFCOLUMNS} >&2
+}
+
+observe () {
+  # syntax: observe message ...
+  #
+  # issue observational message suitable for logging someday when support for
+  # it exists in dpkg
+  if [ -n "$DEBUG_XORG_PACKAGE" ]; then
+    message "$THIS_PACKAGE $THIS_SCRIPT note: $*"
+  fi
+}
+
+warn () {
+  # syntax: warn message ...
+  #
+  # issue warning message suitable for logging someday when support for
+  # it exists in dpkg; also send to standard error
+  message "$THIS_PACKAGE $THIS_SCRIPT warning: $*"
+}
+
+die () {
+  # syntax: die message ...
+  #
+  # exit script with error message
+  message "$THIS_PACKAGE $THIS_SCRIPT error: $*"
+  exit $SHELL_LIB_THROWN_ERROR
+}
+
+internal_error () {
+  # exit script with error; essentially a "THIS SHOULD NEVER HAPPEN" message
+  message "internal error: $*"
+  if [ -n "$OFFICIAL_BUILD" ]; then
+    message "Please report a bug in the $THIS_SCRIPT script of the" \
+            "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+            "Tracking System.  Include all messages above that mention the" \
+            "$THIS_PACKAGE package.  Visit " \
+            "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+            "instructions, read the file" \
+            "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+            "package, or install the reportbug package and use the command of" \
+            "the same name to file a report."
+  fi
+  exit $SHELL_LIB_INTERNAL_ERROR
+}
+
+usage_error () {
+  message "usage error: $*"
+  message "Please report a bug in the $THIS_SCRIPT script of the" \
+          "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+          "Tracking System.  Include all messages above that mention the" \
+          "$THIS_PACKAGE package.  Visit " \
+          "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+          "instructions, read the file" \
+          "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+          "package, or install the reportbug package and use the command of" \
+          "the same name to file a report."
+  exit $SHELL_LIB_USAGE_ERROR
+}
+
+font_update () {
+  # run $UPDATECMDS in $FONTDIRS
+
+  local dir cmd shortcmd x_font_dir_prefix
+
+  x_font_dir_prefix="/usr/share/fonts/X11"
+
+  if [ -z "$UPDATECMDS" ]; then
+    usage_error "font_update() called but \$UPDATECMDS not set"
+  fi
+  if [ -z "$FONTDIRS" ]; then
+    usage_error "font_update() called but \$FONTDIRS not set"
+  fi
+
+  reject_unlikely_path_chars "$UPDATECMDS"
+  reject_unlikely_path_chars "$FONTDIRS"
+
+  for dir in $FONTDIRS; do
+    if [ -d "$x_font_dir_prefix/$dir" ]; then
+      for cmd in $UPDATECMDS; do
+        if which "$cmd" > /dev/null 2>&1; then
+          shortcmd=${cmd##*/}
+          observe "running $shortcmd in $dir font directory"
+	  cmd_opts=
+          if [ "$shortcmd" = "update-fonts-alias" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          if [ "$shortcmd" = "update-fonts-dir" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          if [ "$shortcmd" = "update-fonts-scale" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          $cmd $cmd_opts $dir || warn "$cmd $cmd_opts $dir" \
+                              "failed; font directory data may not" \
+                              "be up to date"
+        else
+          warn "$cmd not found; not updating corresponding $dir font" \
+               "directory data"
+        fi
+      done
+    else
+      warn "$dir is not a directory; not updating font directory data"
+    fi
+  done
+}
+
+remove_conffile_prepare () {
+  # syntax: remove_conffile_prepare filename official_md5sum ...
+  #
+  # Check a conffile "filename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 2 ]; then
+    usage_error "remove_conffile_prepare() called with wrong number of" \
+                "arguments; expected at least 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+  shift
+
+  # does the conffile even exist?
+  if [ -e "$conffile" ]; then
+    # calculate its checksum
+    current_checksum=$(md5sum < "$conffile" | sed 's/[[:space:]].*//')
+    # compare it to each supplied checksum
+    while [ -n "$1" ]; do
+      if [ "$current_checksum" = "$1" ]; then
+        # we found a match; move the confffile and stop looking
+        observe "preparing obsolete conffile $conffile for removal"
+        mv "$conffile" "$conffile.$THIS_PACKAGE-tmp"
+        break
+      fi
+      shift
+    done
+  fi
+}
+
+remove_conffile_lookup () {
+  # syntax: remove_conffile_lookup package filename
+  #
+  # Lookup the md5sum of a conffile in dpkg's database, and prepare for removal
+  # if it matches the actual file's md5sum.
+  #
+  # Call this function when you would call remove_conffile_prepare but only
+  # want to check against dpkg's status database instead of known checksums.
+
+  local package conffile old_md5sum
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "remove_conffile_lookup() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  package="$1"
+  conffile="$2"
+
+  if ! [ -e "$conffile" ]; then
+    return
+  fi
+  old_md5sum="$(dpkg-query -W -f='${Conffiles}' "$package" | \
+    awk '{ if (match($0, "^ '"$conffile"' ")) print $2}')"
+  if [ -n "$old_md5sum" ]; then
+    remove_conffile_prepare "$conffile" "$old_md5sum"
+  fi
+}
+
+remove_conffile_commit () {
+  # syntax: remove_conffile_commit filename
+  #
+  # Complete the removal of a conffile "filename" that has become obsolete.
+  #
+  # Call this function from a postinst script after having used
+  # remove_conffile_prepare() in the preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_commit() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, remove it
+  if [ -e "$conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "committing removal of obsolete conffile $conffile"
+    rm "$conffile.$THIS_PACKAGE-tmp"
+  fi
+}
+
+remove_conffile_rollback () {
+  # syntax: remove_conffile_rollback filename
+  #
+  # Roll back the removal of a conffile "filename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" is  after having used remove_conffile_prepare() in the
+  # preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_rollback() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, move it
+  # back
+  if [ -e "$conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "rolling back removal of obsolete conffile $conffile"
+    mv "$conffile.$THIS_PACKAGE-tmp" "$conffile"
+  fi
+}
+
+replace_conffile_with_symlink_prepare () {
+  # syntax: replace_conffile_with_symlink_prepare oldfilename newfilename \
+  # official_md5sum ...
+  #
+  # Check a conffile "oldfilename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails. Otherwise copy it
+  # to newfilename and let dpkg handle it through conffiles mechanism.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 3 ]; then
+    usage_error "replace_conffile_with_symlink_prepare() called with wrong" \
+                " number of arguments; expected at least 3, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  oldconffile="$1"
+  shift
+  newconffile="$1"
+  shift
+
+  remove_conffile_prepare "$_oldconffile" "$@"
+  # If $oldconffile still exists, then md5sums didn't match.
+  # Copy it to new one.
+  if [ -f "$oldconffile" ]; then
+    cp "$oldconffile" "$newconffile"
+  fi
+
+}
+
+replace_conffile_with_symlink_commit () {
+  # syntax: replace_conffile_with_symlink_commit oldfilename
+  #
+  # Complete the removal of a conffile "oldfilename" that has been
+  # replaced by a symlink.
+  #
+  # Call this function from a postinst script after having used
+  # replace_conffile_with_symlink_prepare() in the preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "replace_conffile_with_symlink_commit() called with wrong" \
+                "number of arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  remove_conffile_commit "$conffile"
+}
+
+replace_conffile_with_symlink_rollback () {
+  # syntax: replace_conffile_with_symlink_rollback oldfilename newfilename
+  #
+  # Roll back the replacing of a conffile "oldfilename" with symlink to
+  # "newfilename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" and verify $2 to ensure the package failed to upgrade
+  # from a version (or install over a version removed-but-not-purged) prior
+  # to the one in which the conffile was obsoleted.
+  # You should have  used replace_conffile_with_symlink_prepare() in the
+  # preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "replace_conffile_with_symlink_rollback() called with wrong" \
+                "number of arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  oldconffile="$1"
+  newconffile="$2"
+
+  remove_conffile_rollback "$_oldconffile"
+  if [ -f "$newconffile" ]; then
+    rm "$newconffile"
+  fi
+}
+
+run () {
+  # syntax: run command [ argument ... ]
+  #
+  # Run specified command with optional arguments and report its exit status.
+  # Useful for commands whose exit status may be nonzero, but still acceptable,
+  # or commands whose failure is not fatal to us.
+  #
+  # NOTE: Do *not* use this function with db_get or db_metaget commands; in
+  # those cases the return value of the debconf command *must* be checked
+  # before the string returned by debconf is used for anything.
+
+  local retval
+
+  # validate arguments
+  if [ $# -lt 1 ]; then
+    usage_error "run() called with wrong number of arguments; expected at" \
+                "least 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  "$@" || retval=$?
+
+  if [ ${retval:-0} -ne 0 ]; then
+    observe "command \"$*\" exited with status $retval"
+  fi
+}
+
+make_symlink_sane () {
+  # syntax: make_symlink_sane symlink target
+  #
+  # Ensure that the symbolic link symlink exists, and points to target.
+  #
+  # If symlink does not exist, create it and point it at target.
+  #
+  # If symlink exists but is not a symbolic link, back it up.
+  #
+  # If symlink exists, is a symbolic link, but points to the wrong location, fix
+  # it.
+  #
+  # If symlink exists, is a symbolic link, and already points to target, do
+  # nothing.
+  #
+  # This function wouldn't be needed if ln had an -I, --idempotent option.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "make_symlink_sane() called with wrong number of arguments;" \
+      "expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local symlink target
+
+  symlink="$1"
+  target="$2"
+
+  if [ -L "$symlink" ] && [ "$(readlink "$symlink")" = "$target" ]; then
+      observe "link from $symlink to $target already exists"
+  else
+    observe "creating symbolic link from $symlink to $target"
+    mkdir -p "${target%/*}" "${symlink%/*}"
+    ln -s -b -S ".dpkg-old" "$target" "$symlink"
+  fi
+}
+
+migrate_dir_to_symlink () {
+  # syntax: migrate_dir_to_symlink old_location new_location
+  #
+  # Per Debian Policy section 6.5.4, "A directory will never be replaced by a
+  # symbolic link to a directory or vice versa; instead, the existing state
+  # (symlink or not) will be left alone and dpkg will follow the symlink if
+  # there is one."
+  #
+  # We have to do it ourselves.
+  #
+  # This function moves the contents of old_location, a directory, into
+  # new_location, a directory, then makes old_location a symbolic link to
+  # new_location.
+  #
+  # old_location need not exist, but if it does, it must be a directory (or a
+  # symlink to a directory).  If it is not, it is backed up.  If new_location
+  # exists already and is not a directory, it is backed up.
+  #
+  # This function should be called from a package's preinst so that other
+  # packages unpacked after this one --- but before this package's postinst runs
+  # --- are unpacked into new_location even if their payloads contain
+  # old_location filespecs.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "migrate_dir_to_symlink() called with wrong number of"
+                "arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local new old
+
+  old="$1"
+  new="$2"
+
+  # Is old location a symlink?
+  if [ -L "$old" ]; then
+    # Does it already point to new location?
+    if [ "$(readlink "$old")" = "$new" ]; then
+      # Nothing to do; migration has already been done.
+      observe "migration of $old to $new already done"
+      return 0
+    else
+      # Back it up.
+      warn "backing up symbolic link $old as $old.dpkg-old"
+      mv -b "$old" "$old.dpkg-old"
+    fi
+  fi
+
+  # Does old location exist, but is not a directory?
+  if [ -e "$old" ] && ! [ -d "$old" ]; then
+      # Back it up.
+      warn "backing up non-directory $old as $old.dpkg-old"
+      mv -b "$old" "$old.dpkg-old"
+  fi
+
+  observe "migrating $old to $new"
+
+  # Is new location a symlink?
+  if [ -L "$new" ]; then
+    # Does it point the wrong way, i.e., back to where we're migrating from?
+    if [ "$(readlink "$new")" = "$old" ]; then
+      # Get rid of it.
+      observe "removing symbolic link $new which points to $old"
+      rm "$new"
+    else
+      # Back it up.
+      warn "backing up symbolic link $new as $new.dpkg-old"
+      mv -b "$new" "$new.dpkg-old"
+    fi
+  fi
+
+  # Does new location exist, but is not a directory?
+  if [ -e "$new" ] && ! [ -d "$new" ]; then
+    warn "backing up non-directory $new as $new.dpkg-old"
+    mv -b "$new" "$new.dpkg-old"
+  fi
+
+  # Create new directory if it does not yet exist.
+  if ! [ -e "$new" ]; then
+    observe "creating $new"
+    mkdir -p "$new"
+  fi
+
+  # Copy files in old location to new location.  Back up any filenames that
+  # already exist in the new location with the extension ".dpkg-old".
+  observe "copying files from $old to $new"
+  if ! (cd "$old" && cp -a -b -S ".dpkg-old" . "$new"); then
+    die "error(s) encountered while copying files from $old to $new"
+  fi
+
+  # Remove files at old location.
+  observe "removing $old"
+  rm -r "$old"
+
+  # Create symlink from old location to new location.
+  make_symlink_sane "$old" "$new"
+}
+
+# vim:set ai et sw=2 ts=2 tw=80:
+
+# GOBSTOPPER: The X Strike Force shell library ends here.
+
+case "$1" in
+abort-install|abort-upgrade)
+  if dpkg --compare-versions "$2" lt-nl "2:1.5.2-1"; then
+    remove_conffile_rollback /etc/X11/xserver/SecurityPolicy
+  fi
+  ;;
+purge)
+  rm /var/log/Xorg.*.log || true
+  rm /var/log/Xorg.*.log.old || true
+  ;;
+esac
+
+#DEBHELPER#
+
+# vim:set ai et sts=2 sw=2 tw=0:
diff --git a/debian/xserver-xorg-core.preinst b/debian/xserver-xorg-core.preinst
new file mode 100644
index 0000000..584d42d
--- /dev/null
+++ b/debian/xserver-xorg-core.preinst
@@ -0,0 +1,646 @@
+#!/bin/sh
+
+set -e
+
+THIS_PACKAGE=xserver-xorg-core
+THIS_SCRIPT=preinst
+
+# This is the X Strike Force shell library for X Window System package
+# maintainer scripts.  It serves to define shell functions commonly used by
+# such packages, and performs some error checking necessary for proper operation
+# of those functions.  By itself, it does not "do" much; the maintainer scripts
+# invoke the functions defined here to accomplish package installation and
+# removal tasks.
+
+# If you are reading this within a Debian package maintainer script (e.g.,
+# /var/lib/dpkg/info/PACKAGE.{config,preinst,postinst,prerm,postrm}), you can
+# skip past this library by scanning forward in this file to the string
+# "GOBSTOPPER".
+
+SOURCE_VERSION=2:1.7.6-2ubuntu7
+OFFICIAL_BUILD=
+
+# Use special abnormal exit codes so that problems with this library are more
+# easily tracked down.
+SHELL_LIB_INTERNAL_ERROR=86
+SHELL_LIB_THROWN_ERROR=74
+SHELL_LIB_USAGE_ERROR=99
+
+# old -> new variable names
+if [ -z "$DEBUG_XORG_PACKAGE" ] && [ -n "$DEBUG_XFREE86_PACKAGE" ]; then
+  DEBUG_XORG_PACKAGE="$DEBUG_XFREE86_PACKAGE"
+fi
+if [ -z "$DEBUG_XORG_DEBCONF" ] && [ -n "$DEBUG_XFREE86_DEBCONF" ]; then
+  DEBUG_XORG_DEBCONF="$DEBUG_XFREE86_DEBCONF"
+fi
+
+# initial sanity checks
+if [ -z "$THIS_PACKAGE" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_PACKAGE shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of this package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ -z "$THIS_SCRIPT" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_SCRIPT shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of the
+"$THIS_PACKAGE" package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ "$1" = "reconfigure" ] || [ -n "$DEBCONF_RECONFIGURE" ]; then
+  RECONFIGURE="true"
+else
+  RECONFIGURE=
+fi
+
+if ([ "$1" = "install" ] || [ "$1" = "configure" ]) && [ -z "$2" ]; then
+  FIRSTINST="yes"
+fi
+
+if [ -z "$RECONFIGURE" ] && [ -z "$FIRSTINST" ]; then
+  UPGRADE="yes"
+fi
+
+trap "message;\
+      message \"Received signal.  Aborting $THIS_PACKAGE package $THIS_SCRIPT script.\";\
+      message;\
+      exit 1" HUP INT QUIT TERM
+
+reject_nondigits () {
+  # syntax: reject_nondigits [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters other than decimal digits and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain anything but digits?
+    if ! expr "$1" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+      # can't use die(), because it wraps message() which wraps this function
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_nondigits() encountered" \
+           "possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+reject_unlikely_path_chars () {
+  # syntax: reject_unlikely_path_chars [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters unlikely to be seen in a path and which the shell might
+  # interpret and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain any funny characters?
+    if expr "$1" : '.*[!$&()*;<>?|].*' > /dev/null 2>&1; then
+      # can't use die(), because I want to avoid forward references
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_unlikely_path_chars()" \
+           "encountered possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+# Query the terminal to establish a default number of columns to use for
+# displaying messages to the user.  This is used only as a fallback in the
+# event the COLUMNS variable is not set.  ($COLUMNS can react to SIGWINCH while
+# the script is running, and this cannot, only being calculated once.)
+DEFCOLUMNS=$(stty size 2> /dev/null | awk '{print $2}') || true
+if ! expr "$DEFCOLUMNS" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+  DEFCOLUMNS=80
+fi
+
+message () {
+  # pretty-print messages of arbitrary length
+  reject_nondigits "$COLUMNS"
+  echo "$*" | fmt -t -w ${COLUMNS:-$DEFCOLUMNS} >&2
+}
+
+observe () {
+  # syntax: observe message ...
+  #
+  # issue observational message suitable for logging someday when support for
+  # it exists in dpkg
+  if [ -n "$DEBUG_XORG_PACKAGE" ]; then
+    message "$THIS_PACKAGE $THIS_SCRIPT note: $*"
+  fi
+}
+
+warn () {
+  # syntax: warn message ...
+  #
+  # issue warning message suitable for logging someday when support for
+  # it exists in dpkg; also send to standard error
+  message "$THIS_PACKAGE $THIS_SCRIPT warning: $*"
+}
+
+die () {
+  # syntax: die message ...
+  #
+  # exit script with error message
+  message "$THIS_PACKAGE $THIS_SCRIPT error: $*"
+  exit $SHELL_LIB_THROWN_ERROR
+}
+
+internal_error () {
+  # exit script with error; essentially a "THIS SHOULD NEVER HAPPEN" message
+  message "internal error: $*"
+  if [ -n "$OFFICIAL_BUILD" ]; then
+    message "Please report a bug in the $THIS_SCRIPT script of the" \
+            "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+            "Tracking System.  Include all messages above that mention the" \
+            "$THIS_PACKAGE package.  Visit " \
+            "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+            "instructions, read the file" \
+            "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+            "package, or install the reportbug package and use the command of" \
+            "the same name to file a report."
+  fi
+  exit $SHELL_LIB_INTERNAL_ERROR
+}
+
+usage_error () {
+  message "usage error: $*"
+  message "Please report a bug in the $THIS_SCRIPT script of the" \
+          "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+          "Tracking System.  Include all messages above that mention the" \
+          "$THIS_PACKAGE package.  Visit " \
+          "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+          "instructions, read the file" \
+          "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+          "package, or install the reportbug package and use the command of" \
+          "the same name to file a report."
+  exit $SHELL_LIB_USAGE_ERROR
+}
+
+font_update () {
+  # run $UPDATECMDS in $FONTDIRS
+
+  local dir cmd shortcmd x_font_dir_prefix
+
+  x_font_dir_prefix="/usr/share/fonts/X11"
+
+  if [ -z "$UPDATECMDS" ]; then
+    usage_error "font_update() called but \$UPDATECMDS not set"
+  fi
+  if [ -z "$FONTDIRS" ]; then
+    usage_error "font_update() called but \$FONTDIRS not set"
+  fi
+
+  reject_unlikely_path_chars "$UPDATECMDS"
+  reject_unlikely_path_chars "$FONTDIRS"
+
+  for dir in $FONTDIRS; do
+    if [ -d "$x_font_dir_prefix/$dir" ]; then
+      for cmd in $UPDATECMDS; do
+        if which "$cmd" > /dev/null 2>&1; then
+          shortcmd=${cmd##*/}
+          observe "running $shortcmd in $dir font directory"
+	  cmd_opts=
+          if [ "$shortcmd" = "update-fonts-alias" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          if [ "$shortcmd" = "update-fonts-dir" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          if [ "$shortcmd" = "update-fonts-scale" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          $cmd $cmd_opts $dir || warn "$cmd $cmd_opts $dir" \
+                              "failed; font directory data may not" \
+                              "be up to date"
+        else
+          warn "$cmd not found; not updating corresponding $dir font" \
+               "directory data"
+        fi
+      done
+    else
+      warn "$dir is not a directory; not updating font directory data"
+    fi
+  done
+}
+
+remove_conffile_prepare () {
+  # syntax: remove_conffile_prepare filename official_md5sum ...
+  #
+  # Check a conffile "filename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 2 ]; then
+    usage_error "remove_conffile_prepare() called with wrong number of" \
+                "arguments; expected at least 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+  shift
+
+  # does the conffile even exist?
+  if [ -e "$conffile" ]; then
+    # calculate its checksum
+    current_checksum=$(md5sum < "$conffile" | sed 's/[[:space:]].*//')
+    # compare it to each supplied checksum
+    while [ -n "$1" ]; do
+      if [ "$current_checksum" = "$1" ]; then
+        # we found a match; move the confffile and stop looking
+        observe "preparing obsolete conffile $conffile for removal"
+        mv "$conffile" "$conffile.$THIS_PACKAGE-tmp"
+        break
+      fi
+      shift
+    done
+  fi
+}
+
+remove_conffile_lookup () {
+  # syntax: remove_conffile_lookup package filename
+  #
+  # Lookup the md5sum of a conffile in dpkg's database, and prepare for removal
+  # if it matches the actual file's md5sum.
+  #
+  # Call this function when you would call remove_conffile_prepare but only
+  # want to check against dpkg's status database instead of known checksums.
+
+  local package conffile old_md5sum
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "remove_conffile_lookup() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  package="$1"
+  conffile="$2"
+
+  if ! [ -e "$conffile" ]; then
+    return
+  fi
+  old_md5sum="$(dpkg-query -W -f='${Conffiles}' "$package" | \
+    awk '{ if (match($0, "^ '"$conffile"' ")) print $2}')"
+  if [ -n "$old_md5sum" ]; then
+    remove_conffile_prepare "$conffile" "$old_md5sum"
+  fi
+}
+
+remove_conffile_commit () {
+  # syntax: remove_conffile_commit filename
+  #
+  # Complete the removal of a conffile "filename" that has become obsolete.
+  #
+  # Call this function from a postinst script after having used
+  # remove_conffile_prepare() in the preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_commit() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, remove it
+  if [ -e "$conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "committing removal of obsolete conffile $conffile"
+    rm "$conffile.$THIS_PACKAGE-tmp"
+  fi
+}
+
+remove_conffile_rollback () {
+  # syntax: remove_conffile_rollback filename
+  #
+  # Roll back the removal of a conffile "filename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" is  after having used remove_conffile_prepare() in the
+  # preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_rollback() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, move it
+  # back
+  if [ -e "$conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "rolling back removal of obsolete conffile $conffile"
+    mv "$conffile.$THIS_PACKAGE-tmp" "$conffile"
+  fi
+}
+
+replace_conffile_with_symlink_prepare () {
+  # syntax: replace_conffile_with_symlink_prepare oldfilename newfilename \
+  # official_md5sum ...
+  #
+  # Check a conffile "oldfilename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails. Otherwise copy it
+  # to newfilename and let dpkg handle it through conffiles mechanism.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 3 ]; then
+    usage_error "replace_conffile_with_symlink_prepare() called with wrong" \
+                " number of arguments; expected at least 3, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  oldconffile="$1"
+  shift
+  newconffile="$1"
+  shift
+
+  remove_conffile_prepare "$_oldconffile" "$@"
+  # If $oldconffile still exists, then md5sums didn't match.
+  # Copy it to new one.
+  if [ -f "$oldconffile" ]; then
+    cp "$oldconffile" "$newconffile"
+  fi
+
+}
+
+replace_conffile_with_symlink_commit () {
+  # syntax: replace_conffile_with_symlink_commit oldfilename
+  #
+  # Complete the removal of a conffile "oldfilename" that has been
+  # replaced by a symlink.
+  #
+  # Call this function from a postinst script after having used
+  # replace_conffile_with_symlink_prepare() in the preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "replace_conffile_with_symlink_commit() called with wrong" \
+                "number of arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  remove_conffile_commit "$conffile"
+}
+
+replace_conffile_with_symlink_rollback () {
+  # syntax: replace_conffile_with_symlink_rollback oldfilename newfilename
+  #
+  # Roll back the replacing of a conffile "oldfilename" with symlink to
+  # "newfilename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" and verify $2 to ensure the package failed to upgrade
+  # from a version (or install over a version removed-but-not-purged) prior
+  # to the one in which the conffile was obsoleted.
+  # You should have  used replace_conffile_with_symlink_prepare() in the
+  # preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "replace_conffile_with_symlink_rollback() called with wrong" \
+                "number of arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  oldconffile="$1"
+  newconffile="$2"
+
+  remove_conffile_rollback "$_oldconffile"
+  if [ -f "$newconffile" ]; then
+    rm "$newconffile"
+  fi
+}
+
+run () {
+  # syntax: run command [ argument ... ]
+  #
+  # Run specified command with optional arguments and report its exit status.
+  # Useful for commands whose exit status may be nonzero, but still acceptable,
+  # or commands whose failure is not fatal to us.
+  #
+  # NOTE: Do *not* use this function with db_get or db_metaget commands; in
+  # those cases the return value of the debconf command *must* be checked
+  # before the string returned by debconf is used for anything.
+
+  local retval
+
+  # validate arguments
+  if [ $# -lt 1 ]; then
+    usage_error "run() called with wrong number of arguments; expected at" \
+                "least 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  "$@" || retval=$?
+
+  if [ ${retval:-0} -ne 0 ]; then
+    observe "command \"$*\" exited with status $retval"
+  fi
+}
+
+make_symlink_sane () {
+  # syntax: make_symlink_sane symlink target
+  #
+  # Ensure that the symbolic link symlink exists, and points to target.
+  #
+  # If symlink does not exist, create it and point it at target.
+  #
+  # If symlink exists but is not a symbolic link, back it up.
+  #
+  # If symlink exists, is a symbolic link, but points to the wrong location, fix
+  # it.
+  #
+  # If symlink exists, is a symbolic link, and already points to target, do
+  # nothing.
+  #
+  # This function wouldn't be needed if ln had an -I, --idempotent option.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "make_symlink_sane() called with wrong number of arguments;" \
+      "expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local symlink target
+
+  symlink="$1"
+  target="$2"
+
+  if [ -L "$symlink" ] && [ "$(readlink "$symlink")" = "$target" ]; then
+      observe "link from $symlink to $target already exists"
+  else
+    observe "creating symbolic link from $symlink to $target"
+    mkdir -p "${target%/*}" "${symlink%/*}"
+    ln -s -b -S ".dpkg-old" "$target" "$symlink"
+  fi
+}
+
+migrate_dir_to_symlink () {
+  # syntax: migrate_dir_to_symlink old_location new_location
+  #
+  # Per Debian Policy section 6.5.4, "A directory will never be replaced by a
+  # symbolic link to a directory or vice versa; instead, the existing state
+  # (symlink or not) will be left alone and dpkg will follow the symlink if
+  # there is one."
+  #
+  # We have to do it ourselves.
+  #
+  # This function moves the contents of old_location, a directory, into
+  # new_location, a directory, then makes old_location a symbolic link to
+  # new_location.
+  #
+  # old_location need not exist, but if it does, it must be a directory (or a
+  # symlink to a directory).  If it is not, it is backed up.  If new_location
+  # exists already and is not a directory, it is backed up.
+  #
+  # This function should be called from a package's preinst so that other
+  # packages unpacked after this one --- but before this package's postinst runs
+  # --- are unpacked into new_location even if their payloads contain
+  # old_location filespecs.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "migrate_dir_to_symlink() called with wrong number of"
+                "arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local new old
+
+  old="$1"
+  new="$2"
+
+  # Is old location a symlink?
+  if [ -L "$old" ]; then
+    # Does it already point to new location?
+    if [ "$(readlink "$old")" = "$new" ]; then
+      # Nothing to do; migration has already been done.
+      observe "migration of $old to $new already done"
+      return 0
+    else
+      # Back it up.
+      warn "backing up symbolic link $old as $old.dpkg-old"
+      mv -b "$old" "$old.dpkg-old"
+    fi
+  fi
+
+  # Does old location exist, but is not a directory?
+  if [ -e "$old" ] && ! [ -d "$old" ]; then
+      # Back it up.
+      warn "backing up non-directory $old as $old.dpkg-old"
+      mv -b "$old" "$old.dpkg-old"
+  fi
+
+  observe "migrating $old to $new"
+
+  # Is new location a symlink?
+  if [ -L "$new" ]; then
+    # Does it point the wrong way, i.e., back to where we're migrating from?
+    if [ "$(readlink "$new")" = "$old" ]; then
+      # Get rid of it.
+      observe "removing symbolic link $new which points to $old"
+      rm "$new"
+    else
+      # Back it up.
+      warn "backing up symbolic link $new as $new.dpkg-old"
+      mv -b "$new" "$new.dpkg-old"
+    fi
+  fi
+
+  # Does new location exist, but is not a directory?
+  if [ -e "$new" ] && ! [ -d "$new" ]; then
+    warn "backing up non-directory $new as $new.dpkg-old"
+    mv -b "$new" "$new.dpkg-old"
+  fi
+
+  # Create new directory if it does not yet exist.
+  if ! [ -e "$new" ]; then
+    observe "creating $new"
+    mkdir -p "$new"
+  fi
+
+  # Copy files in old location to new location.  Back up any filenames that
+  # already exist in the new location with the extension ".dpkg-old".
+  observe "copying files from $old to $new"
+  if ! (cd "$old" && cp -a -b -S ".dpkg-old" . "$new"); then
+    die "error(s) encountered while copying files from $old to $new"
+  fi
+
+  # Remove files at old location.
+  observe "removing $old"
+  rm -r "$old"
+
+  # Create symlink from old location to new location.
+  make_symlink_sane "$old" "$new"
+}
+
+# vim:set ai et sw=2 ts=2 tw=80:
+
+# GOBSTOPPER: The X Strike Force shell library ends here.
+
+case "$1" in
+upgrade|install)
+  if dpkg --compare-versions "$2" lt-nl 2:1.5.2-1; then
+    remove_conffile_lookup xserver-xorg-core /etc/X11/xserver/SecurityPolicy
+  fi
+
+  if dpkg --compare-versions "$2" lt-nl 2:1.7.3.902-1ubuntu6; then 
+    update-alternatives --remove gl_conf /usr/lib/standard-x11/ld.so.conf || true
+  fi
+esac
+
+#DEBHELPER#
+
+exit 0
+
+# vim:set ai et sw=2 ts=2 tw=80:
diff --git a/dix/getevents.c b/dix/getevents.c
index 82bb77b..a2097b7 100644
--- a/dix/getevents.c
+++ b/dix/getevents.c
@@ -719,9 +719,16 @@ moveRelative(DeviceIntPtr dev, int *x, int *y,
     i = (first > 2) ? 0 : 2;
     for (; i < num; i++)
     {
-        dev->last.valuators[i + first] += valuators[i];
-        clipAxis(dev, i, &dev->last.valuators[i + first]);
-        valuators[i] = dev->last.valuators[i + first];
+        if(dev->valuator->axes[i + first].no_integration)
+        {
+            dev->last.valuators[i + first] = valuators[i];
+        }
+        else
+        {
+            dev->last.valuators[i + first] += valuators[i];
+            clipAxis(dev, i, &dev->last.valuators[i + first]);
+            valuators[i] = dev->last.valuators[i + first];
+        }
     }
 }
 
diff --git a/dix/globals.c b/dix/globals.c
index c24a94f..907a5e8 100644
--- a/dix/globals.c
+++ b/dix/globals.c
@@ -124,6 +124,7 @@ FontPtr defaultFont;   /* not declared in dix.h to avoid including font.h in
 CursorPtr rootCursor;
 Bool party_like_its_1989 = FALSE;
 Bool whiteRoot = FALSE;
+Bool bgNoneRoot = FALSE;
 
 int cursorScreenDevPriv[MAXSCREENS];
 
diff --git a/dix/main.c b/dix/main.c
index f96245a..a377d82 100644
--- a/dix/main.c
+++ b/dix/main.c
@@ -168,7 +168,6 @@ int main(int argc, char *argv[], char *envp[])
 	InitBlockAndWakeupHandlers();
 	/* Perform any operating system dependent initializations you'd like */
 	OsInit();
-        config_init();
 	if(serverGeneration == 1)
 	{
 	    CreateWellKnownSockets();
@@ -256,6 +255,7 @@ int main(int argc, char *argv[], char *envp[])
         InitCoreDevices();
 	InitInput(argc, argv);
 	InitAndStartDevices();
+        config_init();
 
 	dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);
 
diff --git a/dix/window.c b/dix/window.c
index 2676a54..e191f09 100644
--- a/dix/window.c
+++ b/dix/window.c
@@ -466,22 +466,24 @@ InitRootWindow(WindowPtr pWin)
     pWin->optional->cursor = rootCursor;
     rootCursor->refcnt++;
 
+    pWin->backingStore = defaultBackingStore;
+    pWin->forcedBS = (defaultBackingStore != NotUseful);
 
     if (party_like_its_1989) {
         MakeRootTile(pWin);
         backFlag |= CWBackPixmap;
+        pScreen->ChangeWindowAttributes(pWin, backFlag);
+    } else if (bgNoneRoot) {
+       /* nothing, handled in xf86CreateRootWindow */
     } else {
 	if (whiteRoot)
             pWin->background.pixel = pScreen->whitePixel;
         else
             pWin->background.pixel = pScreen->blackPixel;
         backFlag |= CWBackPixel;
-    } 
 
-    pWin->backingStore = defaultBackingStore;
-    pWin->forcedBS = (defaultBackingStore != NotUseful);
-    /* We SHOULD check for an error value here XXX */
-    (*pScreen->ChangeWindowAttributes)(pWin, backFlag);
+        pScreen->ChangeWindowAttributes(pWin, backFlag);
+    }
 
     MapWindow(pWin, serverClient);
 }
diff --git a/fb/fbpict.c b/fb/fbpict.c
index c046bae..7c06a64 100644
--- a/fb/fbpict.c
+++ b/fb/fbpict.c
@@ -37,7 +37,7 @@
 #include "mipict.h"
 #include "fbpict.h"
 
-#define mod(a,b) ((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))
+#define mod(a,b) ((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-(a)) % (b))
 
 void
 fbWalkCompositeRegion (CARD8 op,
diff --git a/glx/glxcmdsswap.c b/glx/glxcmdsswap.c
index f1c0ce6..c414dc8 100644
--- a/glx/glxcmdsswap.c
+++ b/glx/glxcmdsswap.c
@@ -354,7 +354,7 @@ int __glXDispSwap_CreateGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)
 
 int __glXDispSwap_DestroyPbuffer(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) req;
+    xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;
     __GLX_DECLARE_SWAP_VARIABLES;
 
     __GLX_SWAP_INT(&req->pbuffer);
@@ -364,7 +364,7 @@ int __glXDispSwap_DestroyPbuffer(__GLXclientState *cl, GLbyte *pc)
 
 int __glXDispSwap_DestroyGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXDestroyGLXPbufferSGIXReq *req = (xGLXDestroyGLXPbufferSGIXReq *) req;
+    xGLXDestroyGLXPbufferSGIXReq *req = (xGLXDestroyGLXPbufferSGIXReq *) pc;
     __GLX_DECLARE_SWAP_VARIABLES;
 
     __GLX_SWAP_INT(&req->pbuffer);
@@ -375,7 +375,7 @@ int __glXDispSwap_DestroyGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)
 int __glXDispSwap_ChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 {
     xGLXChangeDrawableAttributesReq *req =
-	(xGLXChangeDrawableAttributesReq *) req;
+	(xGLXChangeDrawableAttributesReq *) pc;
     __GLX_DECLARE_SWAP_VARIABLES;
     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
     CARD32 *attribs;
@@ -392,7 +392,7 @@ int __glXDispSwap_ChangeDrawableAttributesSGIX(__GLXclientState *cl,
 					       GLbyte *pc)
 {
     xGLXChangeDrawableAttributesSGIXReq *req =
-	(xGLXChangeDrawableAttributesSGIXReq *) req;
+	(xGLXChangeDrawableAttributesSGIXReq *) pc;
     __GLX_DECLARE_SWAP_VARIABLES;
     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
     CARD32 *attribs;
diff --git a/glx/glxdri.c b/glx/glxdri.c
index 6122653..45a125d 100644
--- a/glx/glxdri.c
+++ b/glx/glxdri.c
@@ -968,6 +968,7 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
     const __DRIconfig **driConfigs;
     const __DRIextension **extensions;
     int i;
+    int from = X_ERROR;
 
     if (!xf86LoaderCheckSymbol("DRIQueryDirectRenderingCapable") ||
 	!DRIQueryDirectRenderingCapable(pScreen, &isCapable) ||
@@ -1047,7 +1048,9 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
 
     screen->driver = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);
     if (screen->driver == NULL) {
-	LogMessage(X_ERROR, "AIGLX error: dlopen of %s failed (%s)\n",
+	if (!strcmp(driverName, "nouveau"))
+	    from = X_INFO;
+	LogMessage(from, "AIGLX error: dlopen of %s failed (%s)\n",
 		   filename, dlerror());
         goto handle_error;
     }
@@ -1184,7 +1187,7 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
 
     xfree(screen);
 
-    LogMessage(X_ERROR, "AIGLX: reverting to software rendering\n");
+    LogMessage(from, "AIGLX: reverting to software rendering\n");
 
     return NULL;
 }
diff --git a/glx/glxdri2.c b/glx/glxdri2.c
index ed7fb4c..ed7561b 100644
--- a/glx/glxdri2.c
+++ b/glx/glxdri2.c
@@ -596,6 +596,7 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
     const __DRIextension **extensions;
     const __DRIconfig **driConfigs;
     int i;
+    int from = X_ERROR;
 
     screen = xcalloc(1, sizeof *screen);
     if (screen == NULL)
@@ -622,7 +623,9 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
 
     screen->driver = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);
     if (screen->driver == NULL) {
-	LogMessage(X_ERROR, "AIGLX error: dlopen of %s failed (%s)\n",
+	if (!strcmp(driverName, "nouveau"))
+	    from = X_INFO;
+	LogMessage(from, "AIGLX error: dlopen of %s failed (%s)\n",
 		   filename, dlerror());
         goto handle_error;
     }
@@ -701,7 +704,7 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
 
     xfree(screen);
 
-    LogMessage(X_ERROR, "AIGLX: reverting to software rendering\n");
+    LogMessage(from, "AIGLX: reverting to software rendering\n");
 
     return NULL;
 }
diff --git a/hw/dmx/dmxinit.c b/hw/dmx/dmxinit.c
index e5598e3..b2addfd 100644
--- a/hw/dmx/dmxinit.c
+++ b/hw/dmx/dmxinit.c
@@ -834,7 +834,7 @@ static void dmxSetDefaultFontPath(char *fp)
 /** This function is called in Xserver/os/utils.c from \a AbortServer().
  * We must ensure that backend and console state is restored in the
  * event the server shutdown wasn't clean. */
-void AbortDDX(void)
+void SigAbortDDX(int signo)
 {
     int i;
 
@@ -846,6 +846,11 @@ void AbortDDX(void)
     }
 }
 
+void AbortDDX(void)
+{
+    SigAbortDDX(0);
+}
+
 /** This function is called in Xserver/dix/main.c from \a main() when
  * dispatchException & DE_TERMINATE (which is the only way to exit the
  * main loop without an interruption. */
diff --git a/hw/dmx/dmxinput.c b/hw/dmx/dmxinput.c
index 5203e1a..029961d 100644
--- a/hw/dmx/dmxinput.c
+++ b/hw/dmx/dmxinput.c
@@ -108,6 +108,13 @@ NewInputDeviceRequest (InputOption *options, DeviceIntPtr *pdev)
     return BadRequest;
 }
 
+int
+NewInputDeviceRequest18 (InputOption *options, InputAttributes *attrs,
+                       DeviceIntPtr *pdev)
+{
+    return BadRequest;
+}
+
 void
 DeleteInputDeviceRequest(DeviceIntPtr pDev)
 {
diff --git a/hw/kdrive/src/kdrive.c b/hw/kdrive/src/kdrive.c
index 5cfe54f..83001e1 100644
--- a/hw/kdrive/src/kdrive.c
+++ b/hw/kdrive/src/kdrive.c
@@ -322,7 +322,7 @@ KdProcessSwitch (void)
 }
 
 void
-AbortDDX(void)
+SigAbortDDX(int signo)
 {
     KdDisableScreens ();
     if (kdOsFuncs)
@@ -339,6 +339,12 @@ AbortDDX(void)
 }
 
 void
+AbortDDX(void)
+{
+    SigAbortDDX(0);
+}
+
+void
 ddxGiveUp (void)
 {
     AbortDDX ();
diff --git a/hw/kdrive/src/kinput.c b/hw/kdrive/src/kinput.c
index fb8ebd0..ec4598d 100644
--- a/hw/kdrive/src/kinput.c
+++ b/hw/kdrive/src/kinput.c
@@ -2251,6 +2251,12 @@ ChangeDeviceControl(register ClientPtr client, DeviceIntPtr pDev,
 int
 NewInputDeviceRequest(InputOption *options, DeviceIntPtr *pdev)
 {
+    return NewInputDeviceRequest18(options, NULL, pdev);
+}
+int
+NewInputDeviceRequest18(InputOption *options, InputAttributes *attrs,
+                      DeviceIntPtr *pdev)
+{
     InputOption *option = NULL;
     KdPointerInfo *pi = NULL;
     KdKeyboardInfo *ki = NULL;
@@ -2280,6 +2286,14 @@ NewInputDeviceRequest(InputOption *options, DeviceIntPtr *pdev)
             return BadValue;
         }
 #endif
+#ifdef CONFIG_UDEV
+        else if (strcmp(option->key, "_source") == 0 &&
+                 strcmp(option->value, "server/udev") == 0)
+        {
+            ErrorF("Ignoring device from udev.\n");
+            return BadValue;
+        }
+#endif
     }
 
     if (!ki && !pi) {
diff --git a/hw/vfb/InitOutput.c b/hw/vfb/InitOutput.c
index e7dd1d9..4e30e93 100644
--- a/hw/vfb/InitOutput.c
+++ b/hw/vfb/InitOutput.c
@@ -66,6 +66,7 @@ from The Open Group.
 #endif /* HAS_SHM */
 #include "dix.h"
 #include "miline.h"
+#include "randrstr.h"
 
 #define VFB_DEFAULT_WIDTH      1280
 #define VFB_DEFAULT_HEIGHT     1024
@@ -214,11 +215,17 @@ ddxGiveUp(void)
 }
 
 void
-AbortDDX(void)
+SigAbortDDX(int signo)
 {
     ddxGiveUp();
 }
 
+void
+AbortDDX(void)
+{
+    SigAbortDDX(0);
+}
+
 #ifdef __APPLE__
 void
 DarwinHandleGUI(int argc, char *argv[])
@@ -249,7 +256,7 @@ ddxUseMsg(void)
     ErrorF("-screen scrn WxHxD     set screen's width, height, depth\n");
     ErrorF("-pixdepths list-of-int support given pixmap depths\n");
 #ifdef RENDER
-    ErrorF("+/-render		   turn on/of RENDER extension support"
+    ErrorF("+/-render		   turn on/off RENDER extension support"
 	   "(default on)\n");
 #endif
     ErrorF("-linebias n            adjust thin line pixelization\n");
@@ -904,12 +911,18 @@ vfbScreenInit(int index, ScreenPtr pScreen, int argc, char **argv)
 
     ret = fbScreenInit(pScreen, pbits, pvfb->width, pvfb->height,
 		       dpix, dpiy, pvfb->paddedWidth,pvfb->bitsPerPixel);
+    if (!ret) return FALSE;
+
 #ifdef RENDER
-    if (ret && Render) 
+    if (Render) 
 	fbPictureInit (pScreen, 0, 0);
 #endif
 
-    if (!ret) return FALSE;
+    if (!miRandRInit(pScreen))
+        /* Not sure how to emit warnings in xorg. Should warn here though:
+	 * ("Could not initialise RANDR\n");
+	 */
+        return FALSE;
 
     miInitializeBackingStore(pScreen);
 
diff --git a/hw/xfree86/common/extramodes b/hw/xfree86/common/extramodes
index 4505026..282b2f7 100644
--- a/hw/xfree86/common/extramodes
+++ b/hw/xfree86/common/extramodes
@@ -3,16 +3,75 @@
 //
 // $XFree86: xc/programs/Xserver/hw/xfree86/etc/extramodes,v 1.5 2002/06/05 19:43:05 dawes Exp $
 //
+// NOTE:  Please keep all video modes sorted in order of X res, then Y res for
+//        ease of maintenance and readability.
 
 # 832x624 @ 75Hz (74.55Hz) (fix if the official/Apple spec is different) hsync: 49.725kHz
 ModeLine "832x624" 57.284 832  864  928 1152  624  625  628  667 -Hsync -Vsync
 
+# 1152x864 @ 60.00 Hz (GTF) hsync: 53.70 kHz; pclk: 81.62 MHz
+Modeline "1152x864"  81.62  1152 1216 1336 1520  864 865 868 895  -HSync +Vsync
+
+# 1152x864 @ 70.00 Hz (GTF) hsync: 63.00 kHz; pclk: 96.77 MHz
+Modeline "1152x864"  96.77  1152 1224 1344 1536  864 865 868 900  -HSync +Vsync
+
+# 1152x864 @ 75.00 Hz (GTF) hsync: 67.65 kHz; pclk: 104.99 MHz
+Modeline "1152x864"  104.99  1152 1224 1352 1552  864 865 868 902  -HSync +Vsync
+
+# 1152x864 @ 85.00 Hz (GTF) hsync: 77.10 kHz; pclk: 119.65 MHz
+Modeline "1152x864"  119.65  1152 1224 1352 1552  864 865 868 907  -HSync +Vsync
+
+# 1152x864 @ 85Hz (Red Hat custom modeline)
+ModeLine "1152x864"  121.5 1152 1216 1344 1568    864  865  868  911 +hsync -vsync
+
+# 1152x864 @ 100.00 Hz (GTF) hsync: 91.50 kHz; pclk: 143.47 MHz
+Modeline "1152x864"  143.47  1152 1232 1360 1568  864 865 868 915  -HSync +Vsync
+
+# 1360x768 59.96 Hz (CVT) hsync: 47.37 kHz; pclk: 72.00 MHz
+Modeline "1360x768"   72.00  1360 1408 1440 1520  768 771 781 790 +hsync -vsync
+
+# 1360x768 59.80 Hz (CVT) hsync: 47.72 kHz; pclk: 84.75 MHz
+Modeline "1360x768"   84.75  1360 1432 1568 1776  768 771 781 798 -hsync +vsync
+
 # 1400x1050 @ 60Hz (VESA GTF) hsync: 65.5kHz
 ModeLine "1400x1050" 122.0 1400 1488 1640 1880   1050 1052 1064 1082 +hsync +vsync
 
+# 1400x1050 @ 70.00 Hz (GTF) hsync: 76.51 kHz; pclk: 145.06 MHz
+Modeline "1400x1050"  145.06  1400 1496 1648 1896  1050 1051 1054 1093  -HSync +Vsync
+
 # 1400x1050 @ 75Hz (VESA GTF) hsync: 82.2kHz
 ModeLine "1400x1050" 155.8 1400 1464 1784 1912   1050 1052 1064 1090 +hsync +vsync
 
+# 1400x1050 @ 85.00 Hz (GTF) hsync: 93.76 kHz; pclk: 179.26 MHz
+Modeline "1400x1050"  179.26  1400 1504 1656 1912  1050 1051 1054 1103  -HSync +Vsync
+
+# 1440x900 @ 60.00 Hz (CVT) field rate 59.89 Hz; hsync: 55.93 kHz; pclk: 106.50 MHz
+Modeline "1440x900"  106.50  1440 1520 1672 1904  900 903 909 934  -HSync +Vsync
+
+# 1600x1024 for SGI 1600 SW
+ModeLine "1600x1024" 103.125 1600 1600 1656 1664 1024 1024 1029 1030 +Hsync +Vsync
+
+# 1680x1050 59.88 Hz (CVT 1.76MA-R) hsync: 64.67 kHz; pclk: 119.00 MHz
+Modeline "1680x1050"  119.00  1680 1728 1760 1840  1050 1053 1059 1080 +hsync -vsync
+
+# 1680x1050 59.95 Hz (CVT 1.76MA) hsync: 65.29 kHz; pclk: 146.25 MHz
+Modeline "1680x1050"  146.25  1680 1784 1960 2240  1050 1053 1059 1089 -hsync +vsync
+
+# 1680x1050 69.88 Hz (CVT) hsync: 76.58 kHz; pclk: 174.00 MHz
+Modeline "1680x1050"  174.00  1680 1800 1976 2272  1050 1053 1059 1096 -hsync +vsync
+
+# 1680x1050 74.89 Hz (CVT 1.76MA) hsync: 82.31 kHz; pclk: 187.00 MHz
+Modeline "1680x1050"  187.00  1680 1800 1976 2272  1050 1053 1059 1099 -hsync +vsync
+
+# 1680x1050 84.94 Hz (CVT 1.76MA) hsync: 93.86 kHz; pclk: 214.75 MHz
+Modeline "1680x1050"  214.75  1680 1808 1984 2288  1050 1053 1059 1105 -hsync +vsync
+
+# 1920x1080 59.93 Hz (CVT 2.07M9-R) hsync: 66.59 kHz; pclk: 138.50 MHz
+Modeline "1920x1080"  138.50  1920 1968 2000 2080  1080 1083 1088 1111 +hsync -vsync
+
+# 1920x1200 59.95 Hz (CVT 2.30MA-R) hsync: 74.04 kHz; pclk: 154.00 MHz
+Modeline "1920x1200"  154.00  1920 1968 2000 2080  1200 1203 1209 1235 +hsync -vsync
+
 # 1920x1440 @ 85Hz (VESA GTF) hsync: 128.5kHz
 Modeline "1920x1440" 341.35  1920 2072 2288 2656  1440 1441 1444 1512 -hsync +vsync
 
diff --git a/hw/xfree86/common/xf86AutoConfig.c b/hw/xfree86/common/xf86AutoConfig.c
index a6199b0..248d2ae 100644
--- a/hw/xfree86/common/xf86AutoConfig.c
+++ b/hw/xfree86/common/xf86AutoConfig.c
@@ -44,6 +44,10 @@
 #endif
 #include "dirent.h"
 
+#if defined(__arm__) && defined(__linux__)
+# include "loaderProcs.h"
+#endif
+
 #ifdef sun
 # include <sys/visual_io.h>
 # include <ctype.h>
@@ -179,6 +183,7 @@ videoPtrToDriverList(struct pci_device *dev,
 	case 0x1002:		    driverList[0] = "ati"; break;
 	case 0x102c:		    driverList[0] = "chips"; break;
 	case 0x1013:		    driverList[0] = "cirrus"; break;
+	case 0x1234:		    driverList[0] = "vesa"; break; /* qemu device not supported by cirrus */
 	case 0x3d3d:		    driverList[0] = "glint"; break;
 	case 0x105d:		    driverList[0] = "i128"; break;
 	case 0x8086:
@@ -192,7 +197,36 @@ videoPtrToDriverList(struct pci_device *dev,
 	    break;
 	case 0x102b:		    driverList[0] = "mga";	break;
 	case 0x10c8:		    driverList[0] = "neomagic"; break;
-	case 0x10de: case 0x12d2:   driverList[0] = "nv";	break;
+	case 0x10de: case 0x12d2:
+	    switch (dev->device_id) {
+	    /* NV1 - NV2 are unsupported by nouveau, or nv */
+	    case 0x0008:
+	    case 0x0009:
+	    case 0x0010:
+	        driverList[0] = "vesa";
+		break;
+	    /* NV3 is supported by nv */
+	    case 0x0018:
+	    case 0x0019:
+	        driverList[0] = "nv";
+		break;
+	    /* Everything else is supported by nouveau */
+	    default:
+	        switch (dev->device_id & 0xfff0) {
+		/* These integrated cards apparently don't work with the
+		   nv driver.  Nouveau does support them */
+		case 0x0840:
+		case 0x0860:
+		    driverList[0] = "nouveau";
+		    break;
+		default:
+		    driverList[0] = "nouveau";
+		    driverList[1] = "nv";
+		    break;
+		}
+		break;
+	    }
+	    break;
 	case 0x1106:		    driverList[0] = "openchrome"; break;
 	case 0x1163:		    driverList[0] = "rendition"; break;
 	case 0x5333:
@@ -272,7 +306,8 @@ xf86AutoConfig(void)
     for (cp = builtinConfig; *cp; cp++)
 	xf86ErrorFVerb(3, "\t%s", *cp);
     xf86MsgVerb(X_DEFAULT, 3, "--- End of built-in configuration ---\n");
-    
+
+    xf86initConfigFiles();
     xf86setBuiltinConfig(builtinConfig);
     ret = xf86HandleConfigFile(TRUE);
     FreeConfig();
@@ -404,6 +439,28 @@ matchDriverFromFiles (char** matches, uint16_t match_vendor, uint16_t match_chip
 }
 #endif /* __linux__ */
 
+#if defined(__arm__) && defined(__linux__)
+static int
+test_sysfs_device (char * device_name, char * driver_name)
+{
+    DIR* dir = opendir("/sys/devices/platform");
+    struct dirent *current_dir;
+    int len = strlen(device_name);
+
+    while (current_dir = readdir(dir)) {
+        if (strlen(current_dir->d_name) >= len && strncmp(device_name, current_dir->d_name, len) == 0)
+            break;
+    }
+    closedir(dir);
+    if(!current_dir)
+        return 0;
+
+    if (!LoadModule(driver_name, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
+        return 0;
+    return 1;
+}
+#endif /* defined(__arm__) && defined(__linux__) */
+
 static void
 listPossibleVideoDrivers(char *matches[], int nmatches)
 {
@@ -515,7 +572,18 @@ listPossibleVideoDrivers(char *matches[], int nmatches)
 #if !defined(__linux__) && defined(__sparc__)
 	matches[i++] = xnfstrdup("wsfb");
 #else
+#if defined(__linux__) && defined(__arm__)
+        if (test_sysfs_device("mxc_gpu", "imx"))
+           matches[i++] = xnfstrdup("imx");
+        else if (test_sysfs_device("dovefb", "dovefb"))
+           matches[i++] = xnfstrdup("dovefb");
+        else if (test_sysfs_device("omapfb", "omapfb"))
+           matches[i++] = xnfstrdup("omapfb");
+        else
+	    matches[i++] = xnfstrdup("fbdev");
+#else
 	matches[i++] = xnfstrdup("fbdev");
+#endif /* defined(__linux__) && defined(__arm__) */
 #endif
     }
 }
@@ -544,10 +612,41 @@ chooseVideoDriver(void)
     return chosen_driver;
 }
 
+
+/* copy a screen section and enter the desired driver
+ * and insert it at i in the list of screens */
+static Bool
+copyScreen(confScreenPtr oscreen, GDevPtr odev, int i, char *driver)
+{
+    GDevPtr cptr = NULL;
+
+    xf86ConfigLayout.screens[i].screen = xnfcalloc(1, sizeof(confScreenRec));
+    if(!xf86ConfigLayout.screens[i].screen)
+        return FALSE;
+    memcpy(xf86ConfigLayout.screens[i].screen, oscreen, sizeof(confScreenRec));
+
+    cptr = xcalloc(1, sizeof(GDevRec));
+    if (!cptr)
+        return FALSE;
+    memcpy(cptr, odev, sizeof(GDevRec));
+
+    cptr->identifier = Xprintf("Autoconfigured Video Device %s", driver);
+    cptr->driver = driver;
+
+    /* now associate the new driver entry with the new screen entry */
+    xf86ConfigLayout.screens[i].screen->device = cptr;
+    cptr->myScreenSection = xf86ConfigLayout.screens[i].screen;
+
+    return TRUE;
+}
+
 GDevPtr
 autoConfigDevice(GDevPtr preconf_device)
 {
     GDevPtr ptr = NULL;
+    char *matches[20]; /* If we have more than 20 drivers we're in trouble */
+    int num_matches = 0, num_screens = 0, i;
+    screenLayoutPtr slp;
 
     if (!xf86configptr) {
         return NULL;
@@ -571,14 +670,59 @@ autoConfigDevice(GDevPtr preconf_device)
         ptr->driver = NULL;
     }
     if (!ptr->driver) {
-        ptr->driver = chooseVideoDriver();
-    }
+        /* get all possible video drivers and count them */
+        listPossibleVideoDrivers(matches, 20);
+        for (; matches[num_matches]; num_matches++) {
+            xf86Msg(X_DEFAULT, "Matched %s as autoconfigured driver %d\n",
+                    matches[num_matches], num_matches);
+        }
 
-    /* TODO Handle multiple screen sections */
-    if (xf86ConfigLayout.screens && !xf86ConfigLayout.screens->screen->device) {
-        xf86ConfigLayout.screens->screen->device = ptr;
-        ptr->myScreenSection = xf86ConfigLayout.screens->screen;
+        slp = xf86ConfigLayout.screens;
+        if (slp) {
+            /* count the number of screens and make space for
+             * a new screen for each additional possible driver
+             * minus one for the already existing first one
+             * plus one for the terminating NULL */
+            for (; slp[num_screens].screen; num_screens++);
+            xf86ConfigLayout.screens = xnfcalloc(num_screens + num_matches,
+                                                sizeof(screenLayoutRec));
+            xf86ConfigLayout.screens[0] = slp[0];
+
+            /* do the first match and set that for the original first screen */
+            ptr->driver = matches[0];
+            if (!xf86ConfigLayout.screens[0].screen->device) {
+                xf86ConfigLayout.screens[0].screen->device = ptr;
+                ptr->myScreenSection = xf86ConfigLayout.screens[0].screen;
+            }
+
+            /* for each other driver found, copy the first screen, insert it
+             * into the list of screens and set the driver */
+            i = 0;
+            while (i++ < num_matches) {
+                if (!copyScreen(slp[0].screen, ptr, i, matches[i]))
+                    return NULL;
+            }
+
+            /* shift the rest of the original screen list
+             * to the end of the current screen list
+             *
+             * TODO Handle rest of multiple screen sections */
+            for (i = 1; i < num_screens; i++) {
+                xf86ConfigLayout.screens[i+num_matches] = slp[i];
+            }
+            xf86ConfigLayout.screens[num_screens+num_matches-1].screen = NULL;
+            xfree(slp);
+        } else {
+            /* layout does not have any screens, not much to do */
+            ptr->driver = matches[0];
+            for (i = 1; matches[i] ; i++) {
+                if (matches[i] != matches[0]) {
+                    xfree(matches[i]);
+                }
+            }
+        }
     }
+
     xf86Msg(X_DEFAULT, "Assigned the driver to the xf86ConfigLayout\n");
 
     return ptr;
diff --git a/hw/xfree86/common/xf86Config.c b/hw/xfree86/common/xf86Config.c
index 6fbf613..5692874 100644
--- a/hw/xfree86/common/xf86Config.c
+++ b/hw/xfree86/common/xf86Config.c
@@ -95,6 +95,23 @@ extern DeviceAssocRec mouse_assoc;
 			"%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
 			"%P/lib/X11/%X"
 #endif
+#ifndef ROOT_CONFIGDIRPATH
+#define ROOT_CONFIGDIRPATH	"%A," "%R," \
+				"/etc/X11/%R," "%P/etc/X11/%R," \
+				"/etc/X11/%X-%M," "/etc/X11/%X," "/etc/%X," \
+				"%P/etc/X11/%X.%H," "%P/etc/X11/%X-%M," \
+				"%P/etc/X11/%X," \
+				"%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
+				"%P/lib/X11/%X"
+#endif
+#ifndef USER_CONFIGDIRPATH
+#define USER_CONFIGDIRPATH	"/etc/X11/%S," "%P/etc/X11/%S," \
+				"/etc/X11/%X-%M," "/etc/X11/%X," "/etc/%X," \
+				"%P/etc/X11/%X.%H," "%P/etc/X11/%X-%M," \
+				"%P/etc/X11/%X," \
+				"%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
+				"%P/lib/X11/%X"
+#endif
 #ifndef PROJECTROOT
 #define PROJECTROOT	"/usr/X11R6"
 #endif
@@ -641,11 +658,21 @@ configFiles(XF86ConfFilesPtr fileconf)
   
   /* ModulePath */
 
-  if (fileconf) {
-    if (xf86ModPathFrom != X_CMDLINE && fileconf->file_modulepath) {
+  if (xf86ModPathFrom != X_CMDLINE) {
+    if (fileconf && fileconf->file_modulepath) {
       xf86ModulePath = fileconf->file_modulepath;
       xf86ModPathFrom = X_CONFIG;
     }
+    else if (strcmp(xf86ExtraModulePath, "") != 0) {
+      char *newpath = malloc(strlen(xf86ExtraModulePath)
+			     + strlen(xf86ModulePath)
+			     + 2);
+      strcpy(newpath, xf86ExtraModulePath);
+      strcat(newpath, ",");
+      strcat(newpath, xf86ModulePath);
+
+      xf86ModulePath = newpath;
+    }
   }
 
   xf86Msg(xf86ModPathFrom, "ModulePath set to \"%s\"\n", xf86ModulePath);
@@ -1269,14 +1296,10 @@ checkCoreInputDevices(serverLayoutPtr servlayoutp, Bool implicitLayout)
 	}
     }
 
-    if (!foundPointer) {
-	if (!xf86Info.allowEmptyInput) {
-	    /* This shouldn't happen. */
-	    xf86Msg(X_ERROR, "Cannot locate a core pointer device.\n");
-	    return FALSE;
-	} else {
-	    xf86Msg(X_INFO, "Cannot locate a core pointer device.\n");
-	}
+    if (!foundPointer && !xf86Info.allowEmptyInput) {
+	/* This shouldn't happen. */
+	xf86Msg(X_ERROR, "Cannot locate a core pointer device.\n");
+	return FALSE;
     }
 
     /*
@@ -1413,14 +1436,10 @@ checkCoreInputDevices(serverLayoutPtr servlayoutp, Bool implicitLayout)
 	}
     }
 
-    if (!foundKeyboard) {
-	if (!xf86Info.allowEmptyInput) {
-		/* This shouldn't happen. */
-		xf86Msg(X_ERROR, "Cannot locate a core keyboard device.\n");
-		return FALSE;
-	} else {
-		xf86Msg(X_INFO, "Cannot locate a core keyboard device.\n");
-	}
+    if (!foundKeyboard && !xf86Info.allowEmptyInput) {
+	/* This shouldn't happen. */
+	xf86Msg(X_ERROR, "Cannot locate a core keyboard device.\n");
+	return FALSE;
     }
 
     if (pointerMsg) {
@@ -1444,12 +1463,19 @@ checkCoreInputDevices(serverLayoutPtr servlayoutp, Bool implicitLayout)
     }
 
     if (xf86Info.allowEmptyInput && !(foundPointer && foundKeyboard)) {
-#ifdef CONFIG_HAL
-	xf86Msg(X_INFO, "The server relies on HAL to provide the list of "
+#if defined(CONFIG_HAL) || defined(CONFIG_UDEV)
+	const char *config_backend;
+#if defined(CONFIG_HAL)
+	config_backend = "HAL";
+#else
+	config_backend = "udev";
+#endif
+	xf86Msg(X_INFO, "The server relies on %s to provide the list of "
 	                "input devices.\n\tIf no devices become available, "
-	                "reconfigure HAL or disable AutoAddDevices.\n");
+	                "reconfigure %s or disable AutoAddDevices.\n",
+			config_backend, config_backend);
 #else
-	xf86Msg(X_INFO, "HAL is disabled and no input devices were configured.\n"
+	xf86Msg(X_INFO, "Hotplugging is disabled and no input devices were configured.\n"
 			"\tTry disabling AllowEmptyInput.\n");
 #endif
     }
@@ -1471,6 +1497,45 @@ static OptionInfoRec LayoutOptions[] = {
        {0}, FALSE },
 };
 
+static Bool
+configInputDevices(XF86ConfLayoutPtr layout, serverLayoutPtr servlayoutp)
+{
+    XF86ConfInputrefPtr irp;
+    IDevPtr *indp;
+    int count = 0;
+
+    /*
+     * Count the number of input devices.
+     */
+    irp = layout->lay_input_lst;
+    while (irp) {
+	count++;
+	irp = (XF86ConfInputrefPtr)irp->list.next;
+    }
+    DebugF("Found %d input devices in the layout section %s\n",
+	    count, layout.lay_identifier);
+    indp = xnfcalloc((count + 1), sizeof(IDevPtr));
+    indp[count] = NULL;
+    irp = layout->lay_input_lst;
+    count = 0;
+    while (irp) {
+	indp[count] = xnfalloc(sizeof(IDevRec));
+	if (!configInput(indp[count], irp->iref_inputdev, X_CONFIG)) {
+	    while(count--)
+		xfree(indp[count]);
+	    xfree(indp);
+	    return FALSE;
+	}
+	indp[count]->extraOptions = irp->iref_option_lst;
+	count++;
+	irp = (XF86ConfInputrefPtr)irp->list.next;
+    }
+    servlayoutp->inputs = indp;
+
+    return TRUE;
+}
+
+
 /*
  * figure out which layout is active, which screens are used in that layout,
  * which drivers and monitors are used in these screens
@@ -1481,14 +1546,12 @@ configLayout(serverLayoutPtr servlayoutp, XF86ConfLayoutPtr conf_layout,
 {
     XF86ConfAdjacencyPtr adjp;
     XF86ConfInactivePtr idp;
-    XF86ConfInputrefPtr irp;
     int count = 0;
     int scrnum;
     XF86ConfLayoutPtr l;
     MessageType from;
     screenLayoutPtr slp;
     GDevPtr gdp;
-    IDevPtr* indp;
     int i = 0, j;
 
     if (!servlayoutp)
@@ -1701,37 +1764,13 @@ configLayout(serverLayoutPtr servlayoutp, XF86ConfLayoutPtr conf_layout,
         count++;
         idp = (XF86ConfInactivePtr)idp->list.next;
     }
-    /*
-     * Count the number of input devices.
-     */
-    count = 0;
-    irp = conf_layout->lay_input_lst;
-    while (irp) {
-        count++;
-        irp = (XF86ConfInputrefPtr)irp->list.next;
-    }
-    DebugF("Found %d input devices in the layout section %s\n",
-           count, conf_layout->lay_identifier);
-    indp = xnfcalloc((count + 1), sizeof(IDevPtr));
-    indp[count] = NULL;
-    irp = conf_layout->lay_input_lst;
-    count = 0;
-    while (irp) {
-        indp[count] = xnfalloc(sizeof(IDevRec));
-	if (!configInput(indp[count], irp->iref_inputdev, X_CONFIG)) {
-            while(count--) 
-                xfree(indp[count]);
-            xfree(indp);
-            return FALSE;
-	}
-	indp[count]->extraOptions = irp->iref_option_lst;
-        count++;
-        irp = (XF86ConfInputrefPtr)irp->list.next;
-    }
+
+    if (!configInputDevices(conf_layout, servlayoutp))
+	return FALSE;
+
     servlayoutp->id = conf_layout->lay_identifier;
     servlayoutp->screens = slp;
     servlayoutp->inactives = gdp;
-    servlayoutp->inputs = indp;
     servlayoutp->options = conf_layout->lay_option_lst;
     from = X_DEFAULT;
 
@@ -1743,12 +1782,14 @@ configLayout(serverLayoutPtr servlayoutp, XF86ConfLayoutPtr conf_layout,
  * the only active screen.
  */
 static Bool
-configImpliedLayout(serverLayoutPtr servlayoutp, XF86ConfScreenPtr conf_screen)
+configImpliedLayout(serverLayoutPtr servlayoutp, XF86ConfScreenPtr conf_screen,
+                    XF86ConfigPtr xf86configptr)
 {
     MessageType from;
     XF86ConfScreenPtr s;
     screenLayoutPtr slp;
     IDevPtr *indp;
+    XF86ConfLayoutRec layout;
 
     if (!servlayoutp)
 	return FALSE;
@@ -1784,10 +1825,19 @@ configImpliedLayout(serverLayoutPtr servlayoutp, XF86ConfScreenPtr conf_screen)
     servlayoutp->screens = slp;
     servlayoutp->inactives = xnfcalloc(1, sizeof(GDevRec));
     servlayoutp->options = NULL;
-    /* Set up an empty input device list, then look for some core devices. */
-    indp = xnfalloc(sizeof(IDevPtr));
-    *indp = NULL;
-    servlayoutp->inputs = indp;
+
+    memset(&layout, 0, sizeof(layout));
+    layout.lay_identifier = servlayoutp->id;
+    if (xf86layoutAddInputDevices(xf86configptr, &layout) > 0) {
+	if (!configInputDevices(&layout, servlayoutp))
+	    return FALSE;
+	from = X_DEFAULT;
+    } else {
+	/* Set up an empty input device list, then look for some core devices. */
+	indp = xnfalloc(sizeof(IDevPtr));
+	*indp = NULL;
+	servlayoutp->inputs = indp;
+    }
 
     return TRUE;
 }
@@ -2428,34 +2478,53 @@ checkInput(serverLayoutPtr layout, Bool implicit_layout) {
 ConfigStatus
 xf86HandleConfigFile(Bool autoconfig)
 {
-    const char *filename;
-    char *searchpath;
-    MessageType from = X_DEFAULT;
+    const char *filename, *dirname;
+    char *filesearch, *dirsearch;
+    MessageType filefrom = X_DEFAULT;
+    MessageType dirfrom = X_DEFAULT;
     char *scanptr;
     Bool singlecard = 0;
     Bool implicit_layout = FALSE;
 
     if (!autoconfig) {
-	if (getuid() == 0)
-	    searchpath = ROOT_CONFIGPATH;
-	else
-	    searchpath = USER_CONFIGPATH;
+	if (getuid() == 0) {
+	    filesearch = ROOT_CONFIGPATH;
+	    dirsearch = ROOT_CONFIGDIRPATH;
+	} else {
+	    filesearch = USER_CONFIGPATH;
+	    dirsearch = USER_CONFIGDIRPATH;
+	}
 
 	if (xf86ConfigFile)
-	    from = X_CMDLINE;
+	    filefrom = X_CMDLINE;
+	if (xf86ConfigDir)
+	    dirfrom = X_CMDLINE;
 
-	filename = xf86openConfigFile(searchpath, xf86ConfigFile, PROJECTROOT);
+	xf86initConfigFiles();
+	dirname = xf86openConfigDirFiles(dirsearch, xf86ConfigDir, PROJECTROOT);
+	filename = xf86openConfigFile(filesearch, xf86ConfigFile, PROJECTROOT);
 	if (filename) {
-	    xf86MsgVerb(from, 0, "Using config file: \"%s\"\n", filename);
+	    xf86MsgVerb(filefrom, 0, "Using config file: \"%s\"\n", filename);
 	    xf86ConfigFile = xnfstrdup(filename);
 	} else {
 	    if (xf86ConfigFile)
 		xf86Msg(X_ERROR, "Unable to locate/open config file: \"%s\"\n",
 			xf86ConfigFile);
-	    return CONFIG_NOFILE;
 	}
+	if (dirname) {
+	    xf86MsgVerb(dirfrom, 0, "Using config directory: \"%s\"\n",
+			dirname);
+	    xf86ConfigDir = xnfstrdup(dirname);
+	} else {
+	    if (xf86ConfigDir)
+		xf86Msg(X_ERROR,
+			"Unable to locate/open config directory: \"%s\"\n",
+			xf86ConfigDir);
+	}
+	if (!filename && !dirname)
+	    return CONFIG_NOFILE;
     }
-     
+
     if ((xf86configptr = xf86readConfigFile ()) == NULL) {
 	xf86Msg(X_ERROR, "Problem parsing the config file\n");
 	return CONFIG_PARSE_ERROR;
@@ -2481,7 +2550,8 @@ xf86HandleConfigFile(Bool autoconfig)
 		    "No Layout section.  Using the first Screen section.\n");
 	}
 	if (!configImpliedLayout(&xf86ConfigLayout,
-				 xf86configptr->conf_screen_lst)) {
+				 xf86configptr->conf_screen_lst,
+				 xf86configptr)) {
             xf86Msg(X_ERROR, "Unable to determine the screen layout\n");
 	    return CONFIG_PARSE_ERROR;
 	}
diff --git a/hw/xfree86/common/xf86Events.c b/hw/xfree86/common/xf86Events.c
index 8e6a15b..862aab2 100644
--- a/hw/xfree86/common/xf86Events.c
+++ b/hw/xfree86/common/xf86Events.c
@@ -363,6 +363,8 @@ xf86InterceptSigIll(void (*sigillhandler)(void))
 int
 xf86SigWrapper(int signo)
 {
+  static Bool beenhere = FALSE;
+
   if ((signo == SIGILL) && xf86SigIllHandler) {
     (*xf86SigIllHandler)();
     return 0; /* continue */
diff --git a/hw/xfree86/common/xf86Globals.c b/hw/xfree86/common/xf86Globals.c
index 98f8284..2d917ec 100644
--- a/hw/xfree86/common/xf86Globals.c
+++ b/hw/xfree86/common/xf86Globals.c
@@ -132,7 +132,7 @@ xf86InfoRec xf86Info = {
     .kbdCustomKeycodes          = FALSE,
     .disableRandR               = FALSE,
     .randRFrom                  = X_DEFAULT,
-#ifdef CONFIG_HAL
+#if defined(CONFIG_HAL) || defined(CONFIG_UDEV)
     .allowEmptyInput            = TRUE,
     .autoAddDevices             = TRUE,
     .autoEnableDevices          = TRUE
@@ -143,7 +143,9 @@ xf86InfoRec xf86Info = {
 #endif
 };
 const char *xf86ConfigFile = NULL;
+const char *xf86ConfigDir = NULL;
 const char *xf86ModulePath = DEFAULT_MODULE_PATH;
+const char *xf86ExtraModulePath = EXTRA_MODULE_PATH;
 MessageType xf86ModPathFrom = X_DEFAULT;
 const char *xf86LogFile = DEFAULT_LOGPREFIX;
 MessageType xf86LogFileFrom = X_DEFAULT;
diff --git a/hw/xfree86/common/xf86Init.c b/hw/xfree86/common/xf86Init.c
index d3de670..a971e28 100644
--- a/hw/xfree86/common/xf86Init.c
+++ b/hw/xfree86/common/xf86Init.c
@@ -77,6 +77,7 @@
 #ifdef RENDER
 #include "picturestr.h"
 #endif
+#include "xace.h"
 
 #include "xf86VGAarbiter.h"
 #include "globals.h"
@@ -249,6 +250,7 @@ xf86CreateRootWindow(WindowPtr pWin)
   int ret = TRUE;
   int err = Success;
   ScreenPtr pScreen = pWin->drawable.pScreen;
+  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   RootWinPropPtr pProp;
   CreateWindowProcPtr CreateWindow = (CreateWindowProcPtr)
       dixLookupPrivate(&pScreen->devPrivates, xf86CreateRootWindowKey);
@@ -300,6 +302,15 @@ xf86CreateRootWindow(WindowPtr pWin)
     }
   }
 
+  if (bgNoneRoot && pScrn->canDoBGNoneRoot) {
+      pWin->backgroundState = XaceBackgroundNoneState(pWin);
+      pWin->background.pixel = pScreen->whitePixel;
+      pScreen->ChangeWindowAttributes(pWin, CWBackPixmap | CWBorderPixel | CWCursor | CWBackingStore);
+  } else {
+      pWin->background.pixel = pScreen->blackPixel;
+      pScreen->ChangeWindowAttributes(pWin, CWBackPixel | CWBorderPixel | CWCursor | CWBackingStore);
+  }
+
   DebugF("xf86CreateRootWindow() returns %d\n", ret);
   return (ret);
 }
@@ -1144,6 +1155,9 @@ OsVendorInit(void)
 
   if (!beenHere) {
     umask(022);
+    /* have glibc report internal abort traces to stderr instead of
+       the controlling terminal */
+    setenv("LIBC_FATAL_STDERR_","1",0);
     xf86LogInit();
   }
 
@@ -1174,14 +1188,17 @@ OsVendorInit(void)
 }
 
 /*
- * ddxGiveUp --
+ * ddxSigGiveUp --
  *      Device dependent cleanup. Called by by dix before normal server death.
  *      For SYSV386 we must switch the terminal back to normal mode. No error-
  *      checking here, since there should be restored as much as possible.
+ *
+ *      If a non-zero signo is passed, re-raise that signal rather than
+ *      calling abort().
  */
 
 void
-ddxGiveUp(void)
+ddxSigGiveUp(int signo)
 {
     int i;
 
@@ -1207,24 +1224,45 @@ ddxGiveUp(void)
 
     xf86CloseConsole();
 
+    ErrorF (" ddxSigGiveUp: Closing log\n");
     xf86CloseLog();
 
     /* If an unexpected signal was caught, dump a core for debugging */
-    if (xf86Info.caughtSignal)
-	abort();
+    if (xf86Info.caughtSignal) {
+        if (signo != 0) {
+            raise(signo);
+        } else {
+            abort();
+        }
+    }
 }
 
+/*
+ * ddxGiveUp --
+ *      Device dependent cleanup. Called by by dix before normal server death.
+ *      For SYSV386 we must switch the terminal back to normal mode. No error-
+ *      checking here, since there should be restored as much as possible.
+ */
+
+void
+ddxGiveUp()
+{
+    ddxSigGiveUp(0);
+}
 
 
 /*
- * AbortDDX --
+ * SigAbortDDX --
  *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
  *      made to restore all original setting of the displays. Also all devices
  *      are closed.
+ *
+ *      If a non-zero signo is passed, re-raise that signal rather than calling
+ *      abort()
  */
 
 void
-AbortDDX(void)
+SigAbortDDX(int signo)
 {
   int i;
 
@@ -1255,7 +1293,20 @@ AbortDDX(void)
    * This is needed for an abnormal server exit, since the normal exit stuff
    * MUST also be performed (i.e. the vt must be left in a defined state)
    */
-  ddxGiveUp();
+  ddxSigGiveUp(signo);
+}
+
+/*
+ * AbortDDX --
+ *      DDX - specific abort routine.  The attempt is made to restore
+ *      all original setting of the displays. Also all devices are
+ *      closed.
+ */
+
+void
+AbortDDX()
+{
+    SigAbortDDX(0);
 }
 
 void
@@ -1373,6 +1424,19 @@ ddxProcessArgument(int argc, char **argv, int i)
     xf86ConfigFile = argv[i + 1];
     return 2;
   }
+  if (!strcmp(argv[i], "-configdir"))
+  {
+    CHECK_FOR_REQUIRED_ARGUMENT();
+    if (getuid() != 0 && !xf86PathIsSafe(argv[i + 1])) {
+      FatalError("\nInvalid argument for %s\n"
+	  "\tFor non-root users, the file specified with %s must be\n"
+	  "\ta relative path and must not contain any \"..\" elements.\n"
+	  "\tUsing default "__XCONFIGDIR__" search path.\n\n",
+	  argv[i], argv[i]);
+    }
+    xf86ConfigDir = argv[i + 1];
+    return 2;
+  }
   if (!strcmp(argv[i],"-flipPixels"))
   {
     xf86FlipPixels = TRUE;
@@ -1656,6 +1720,8 @@ ddxUseMsg(void)
   }
   ErrorF("-config file           specify a configuration file, relative to the\n");
   ErrorF("                       "__XCONFIGFILE__" search path, only root can use absolute\n");
+  ErrorF("-configdir dir         specify a configuration directory, relative to the\n");
+  ErrorF("                       "__XCONFIGDIR__" search path, only root can use absolute\n");
   ErrorF("-verbose [n]           verbose startup messages\n");
   ErrorF("-logverbose [n]        verbose log messages\n");
   ErrorF("-quiet                 minimal startup messages\n");
diff --git a/hw/xfree86/common/xf86Option.c b/hw/xfree86/common/xf86Option.c
index ad8d1c4..a2868bf 100644
--- a/hw/xfree86/common/xf86Option.c
+++ b/hw/xfree86/common/xf86Option.c
@@ -42,6 +42,7 @@
 #include "xf86.h"
 #include "xf86Xinput.h"
 #include "xf86Optrec.h"
+#include "xf86Parser.h"
 
 static Bool ParseOptionValue(int scrnIndex, pointer options, OptionInfoPtr p,
 			     Bool markUsed);
@@ -456,29 +457,7 @@ xf86ShowUnusedOptions(int scrnIndex, pointer options)
 static Bool
 GetBoolValue(OptionInfoPtr p, const char *s)
 {
-    if (*s == '\0') {
-	p->value.bool = TRUE;
-    } else {
-	if (xf86NameCmp(s, "1") == 0)
-	    p->value.bool = TRUE;
-	else if (xf86NameCmp(s, "on") == 0)
-	    p->value.bool = TRUE;
-	else if (xf86NameCmp(s, "true") == 0)
-	    p->value.bool = TRUE;
-	else if (xf86NameCmp(s, "yes") == 0)
-	    p->value.bool = TRUE;
-	else if (xf86NameCmp(s, "0") == 0)
-	    p->value.bool = FALSE;
-	else if (xf86NameCmp(s, "off") == 0)
-	    p->value.bool = FALSE;
-	else if (xf86NameCmp(s, "false") == 0)
-	    p->value.bool = FALSE;
-	else if (xf86NameCmp(s, "no") == 0)
-	    p->value.bool = FALSE;
-	else
-	    return FALSE;
-    }
-    return TRUE;
+    return xf86getBoolValue(&p->value.bool, s);
 }
 
 static Bool
diff --git a/hw/xfree86/common/xf86Priv.h b/hw/xfree86/common/xf86Priv.h
index 3bb1571..ddea841 100644
--- a/hw/xfree86/common/xf86Priv.h
+++ b/hw/xfree86/common/xf86Priv.h
@@ -46,6 +46,7 @@
  * The global state of these things is held in xf86InfoRec (when appropriate).
  */
 extern _X_EXPORT const char *xf86ConfigFile;
+extern _X_EXPORT const char *xf86ConfigDir;
 extern _X_EXPORT  Bool xf86AllowMouseOpenFail;
 #ifdef XF86VIDMODE
 extern _X_EXPORT  Bool xf86VidModeDisabled;
@@ -77,6 +78,7 @@ extern _X_EXPORT  struct pci_slot_match xf86IsolateDevice;
 
 extern _X_EXPORT  xf86InfoRec xf86Info;
 extern _X_EXPORT  const char *xf86ModulePath;
+extern _X_EXPORT  const char *xf86ExtraModulePath;
 extern _X_EXPORT  MessageType xf86ModPathFrom;
 extern _X_EXPORT  const char *xf86LogFile;
 extern _X_EXPORT  MessageType xf86LogFileFrom;
diff --git a/hw/xfree86/common/xf86VidMode.c b/hw/xfree86/common/xf86VidMode.c
index 49b86e7..b618573 100644
--- a/hw/xfree86/common/xf86VidMode.c
+++ b/hw/xfree86/common/xf86VidMode.c
@@ -220,6 +220,9 @@ VidModeGetFirstModeline(int scrnIndex, pointer *mode, int *dotClock)
 
     pScrn = xf86Screens[scrnIndex];
     pVidMode = VMPTR(pScrn->pScreen);
+    if (pScrn->modes == NULL)
+        return FALSE;
+
     pVidMode->First = pScrn->modes;
     pVidMode->Next =  pVidMode->First->next;
 
diff --git a/hw/xfree86/common/xf86Xinput.c b/hw/xfree86/common/xf86Xinput.c
index f637cfe..bbd8bcc 100644
--- a/hw/xfree86/common/xf86Xinput.c
+++ b/hw/xfree86/common/xf86Xinput.c
@@ -57,9 +57,11 @@
 #include <X11/Xatom.h>
 #include "xf86.h"
 #include "xf86Priv.h"
+#include "xf86Config.h"
 #include "xf86Xinput.h"
 #include "XIstubs.h"
 #include "xf86Optrec.h"
+#include "xf86Parser.h"
 #include "mipointer.h"
 #include "xf86InPriv.h"
 #include "compiler.h"
@@ -74,6 +76,11 @@
 #include "exglobals.h"
 #include "eventstr.h"
 
+#include <string.h>     /* InputClassMatches */
+#ifdef HAVE_FNMATCH_H
+#include <fnmatch.h>
+#endif
+
 #include "extnsionst.h"
 
 #include "windowstr.h"	/* screenIsSaved */
@@ -191,12 +198,12 @@ ProcessVelocityConfiguration(DeviceIntPtr pDev, char* devname, pointer list,
 
 static void
 ApplyAccelerationSettings(DeviceIntPtr dev){
-    int scheme;
+    int scheme, i;
     DeviceVelocityPtr pVel;
     LocalDevicePtr local = (LocalDevicePtr)dev->public.devicePrivate;
     char* schemeStr;
 
-    if(dev->valuator){
+    if (dev->valuator && dev->ptrfeed) {
 	schemeStr = xf86SetStrOption(local->options, "AccelerationScheme", "");
 
 	scheme = dev->valuator->accelScheme.number;
@@ -239,6 +246,30 @@ ApplyAccelerationSettings(DeviceIntPtr dev){
                                               pVel);
                 break;
         }
+
+        i = xf86SetIntOption(local->options, "AccelerationNumerator",
+                             dev->ptrfeed->ctrl.num);
+        if (i >= 0)
+            dev->ptrfeed->ctrl.num = i;
+
+        i = xf86SetIntOption(local->options, "AccelerationDenominator",
+                             dev->ptrfeed->ctrl.den);
+        if (i > 0)
+            dev->ptrfeed->ctrl.den = i;
+
+        i = xf86SetIntOption(local->options, "AccelerationThreshold",
+                             dev->ptrfeed->ctrl.threshold);
+        if (i >= 0)
+            dev->ptrfeed->ctrl.threshold = i;
+
+        /* mostly a no-op anyway */
+        (*dev->ptrfeed->CtrlProc)(dev, &dev->ptrfeed->ctrl);
+
+        xf86Msg(X_CONFIG, "%s: (accel) acceleration factor: %.3f\n",
+                            local->name, ((float)dev->ptrfeed->ctrl.num)/
+                                         ((float)dev->ptrfeed->ctrl.den));
+        xf86Msg(X_CONFIG, "%s: (accel) acceleration threshold: %i\n",
+                local->name, dev->ptrfeed->ctrl.threshold);
     }
 }
 
@@ -466,6 +497,157 @@ AddOtherInputDevices(void)
 {
 }
 
+/*
+ * Classes without any Match statements match all devices. Otherwise, all
+ * statements must match.
+ */
+static Bool
+InputClassMatches(XF86ConfInputClassPtr iclass, InputAttributes *attrs)
+{
+    char **cur;
+    Bool match;
+
+    if (iclass->match_product) {
+        if (!attrs->product)
+            return FALSE;
+        /* see if any of the values match */
+        for (cur = iclass->match_product, match = FALSE; *cur; cur++)
+            if (strstr(attrs->product, *cur)) {
+                match = TRUE;
+                break;
+            }
+        if (!match)
+            return FALSE;
+    }
+    if (iclass->match_vendor) {
+        if (!attrs->vendor)
+            return FALSE;
+        /* see if any of the values match */
+        for (cur = iclass->match_vendor, match = FALSE; *cur; cur++)
+            if (strstr(attrs->vendor, *cur)) {
+                match = TRUE;
+                break;
+            }
+        if (!match)
+            return FALSE;
+    }
+    if (iclass->match_device) {
+        if (!attrs->device)
+            return FALSE;
+        /* see if any of the values match */
+        for (cur = iclass->match_device, match = FALSE; *cur; cur++)
+#ifdef HAVE_FNMATCH_H
+            if (fnmatch(*cur, attrs->device, FNM_PATHNAME) == 0) {
+#else
+            if (strstr(attrs->device, *cur)) {
+#endif
+                match = TRUE;
+                break;
+            }
+        if (!match)
+            return FALSE;
+    }
+    if (iclass->match_tag) {
+        if (!attrs->tags)
+            return FALSE;
+
+        for (cur = iclass->match_tag, match = FALSE; *cur && !match; cur++) {
+            const char *tag;
+            for(tag = *attrs->tags; *tag; tag++) {
+                if (!strcmp(tag, *cur)) {
+                    match = TRUE;
+                    break;
+                }
+            }
+        }
+
+        if (!match)
+            return FALSE;
+    }
+
+    if (iclass->is_keyboard.set &&
+        iclass->is_keyboard.val != !!(attrs->flags & ATTR_KEYBOARD))
+        return FALSE;
+    if (iclass->is_pointer.set &&
+        iclass->is_pointer.val != !!(attrs->flags & ATTR_POINTER))
+        return FALSE;
+    if (iclass->is_joystick.set &&
+        iclass->is_joystick.val != !!(attrs->flags & ATTR_JOYSTICK))
+        return FALSE;
+    if (iclass->is_tablet.set &&
+        iclass->is_tablet.val != !!(attrs->flags & ATTR_TABLET))
+        return FALSE;
+    if (iclass->is_touchpad.set &&
+        iclass->is_touchpad.val != !!(attrs->flags & ATTR_TOUCHPAD))
+        return FALSE;
+    if (iclass->is_touchscreen.set &&
+        iclass->is_touchscreen.val != !!(attrs->flags & ATTR_TOUCHSCREEN))
+        return FALSE;
+    return TRUE;
+}
+
+/*
+ * Merge in any InputClass configurations. Options in each InputClass
+ * section have more priority than the original device configuration as
+ * well as any previous InputClass sections.
+ */
+static int
+MergeInputClasses(IDevPtr idev, InputAttributes *attrs)
+{
+    XF86ConfInputClassPtr cl;
+    XF86OptionPtr classopts, mergedopts = NULL;
+    char *classdriver = NULL;
+
+    for (cl = xf86configptr->conf_inputclass_lst; cl; cl = cl->list.next) {
+        if (!InputClassMatches(cl, attrs))
+            continue;
+
+        /* Collect class options and merge over previous classes */
+        xf86Msg(X_CONFIG, "%s: Applying InputClass \"%s\"\n",
+                idev->identifier, cl->identifier);
+        if (cl->driver)
+            classdriver = cl->driver;
+        classopts = xf86optionListDup(cl->option_lst);
+        mergedopts = xf86optionListMerge(mergedopts, classopts);
+    }
+
+    /* Apply options to device with InputClass settings preferred. */
+    if (classdriver) {
+        xfree(idev->driver);
+        idev->driver = xstrdup(classdriver);
+        if (!idev->driver) {
+            xf86Msg(X_ERROR, "Failed to allocate memory while merging "
+                    "InputClass configuration");
+            return BadAlloc;
+        }
+        mergedopts = xf86ReplaceStrOption(mergedopts, "driver", idev->driver);
+    }
+    idev->commonOptions = xf86optionListMerge(idev->commonOptions, mergedopts);
+
+    return Success;
+}
+
+static Bool
+IgnoreInputClass(IDevPtr idev, InputAttributes *attrs)
+{
+    XF86ConfInputClassPtr cl;
+    Bool ignore;
+
+    for (cl = xf86configptr->conf_inputclass_lst; cl; cl = cl->list.next) {
+        if (!InputClassMatches(cl, attrs))
+            continue;
+        if (xf86findOption(cl->option_lst, "Ignore")) {
+            ignore = xf86CheckBoolOption(cl->option_lst, "Ignore", FALSE);
+            if (ignore)
+                xf86Msg(X_CONFIG,
+                        "%s: Ignoring device from InputClass \"%s\"\n",
+                        idev->identifier, cl->identifier);
+            return ignore;
+        }
+    }
+    return FALSE;
+}
+
 /**
  * Create a new input device, activate and enable it.
  *
@@ -570,6 +752,13 @@ unwind:
 int
 NewInputDeviceRequest (InputOption *options, DeviceIntPtr *pdev)
 {
+    return NewInputDeviceRequest18(options, NULL, pdev);
+}
+
+int
+NewInputDeviceRequest18 (InputOption *options, InputAttributes *attrs,
+                       DeviceIntPtr *pdev)
+{
     IDevRec *idev = NULL;
     InputOption *option = NULL;
     int rval = Success;
@@ -605,9 +794,9 @@ NewInputDeviceRequest (InputOption *options, DeviceIntPtr *pdev)
             }
         }
 
-        /* Right now, the only automatic config we know of is HAL. */
         if (strcmp(option->key, "_source") == 0 &&
-            strcmp(option->value, "server/hal") == 0) {
+            (strcmp(option->value, "server/hal") == 0 ||
+             strcmp(option->value, "server/udev") == 0)) {
             is_auto = 1;
             if (!xf86Info.autoAddDevices) {
                 rval = BadMatch;
@@ -615,16 +804,6 @@ NewInputDeviceRequest (InputOption *options, DeviceIntPtr *pdev)
             }
         }
     }
-    if (!idev->driver || !idev->identifier) {
-        xf86Msg(X_ERROR, "No input driver/identifier specified (ignoring)\n");
-        rval = BadRequest;
-        goto unwind;
-    }
-
-    if (!idev->identifier) {
-        xf86Msg(X_ERROR, "No device identifier specified (ignoring)\n");
-        return BadMatch;
-    }
 
     for (option = options; option; option = option->next) {
         /* Steal option key/value strings from the provided list.
@@ -635,6 +814,29 @@ NewInputDeviceRequest (InputOption *options, DeviceIntPtr *pdev)
         option->value = NULL;
     }
 
+    /* Apply InputClass settings */
+    if (attrs) {
+        if (IgnoreInputClass(idev, attrs)) {
+            rval = BadIDChoice;
+            goto unwind;
+        }
+
+        rval = MergeInputClasses(idev, attrs);
+        if (rval != Success)
+            goto unwind;
+    }
+
+    if (!idev->driver || !idev->identifier) {
+        xf86Msg(X_INFO, "No input driver/identifier specified (ignoring)\n");
+        rval = BadRequest;
+        goto unwind;
+    }
+
+    if (!idev->identifier) {
+        xf86Msg(X_INFO, "No device identifier specified (ignoring)\n");
+        return BadMatch;
+    }
+
     rval = xf86NewInputDevice(idev, pdev,
                 (!is_auto || (is_auto && xf86Info.autoEnableDevices)));
     if (rval == Success)
@@ -1028,6 +1230,12 @@ xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval,
 			   max_res);
 }
 
+void
+xf86SetValuatorAxisNoIntegration(DeviceIntPtr dev, int axnum, Bool no_integration)
+{
+    SetValuatorAxisNoIntegration(dev, axnum, no_integration);
+}
+
 /*
  * Set the valuator values to be in synch with dix/event.c
  * DefineInitialRootWindow().
diff --git a/hw/xfree86/common/xf86Xinput.h b/hw/xfree86/common/xf86Xinput.h
index aa9e9d5..5ad81f7 100644
--- a/hw/xfree86/common/xf86Xinput.h
+++ b/hw/xfree86/common/xf86Xinput.h
@@ -190,6 +190,7 @@ extern _X_EXPORT void xf86ProcessCommonOptions(InputInfoPtr pInfo, pointer optio
 extern _X_EXPORT void xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval,
 				int maxval, int resolution, int min_res,
 				int max_res);
+extern _X_EXPORT void xf86SetValuatorAxisNoIntegration(DeviceIntPtr dev, int axnum, Bool no_integration);
 extern _X_EXPORT void xf86InitValuatorDefaults(DeviceIntPtr dev, int axnum);
 extern _X_EXPORT void xf86AddEnabledDevice(InputInfoPtr pInfo);
 extern _X_EXPORT void xf86RemoveEnabledDevice(InputInfoPtr pInfo);
diff --git a/hw/xfree86/common/xf86pciBus.c b/hw/xfree86/common/xf86pciBus.c
index ac018e7..c00391c 100644
--- a/hw/xfree86/common/xf86pciBus.c
+++ b/hw/xfree86/common/xf86pciBus.c
@@ -141,8 +141,8 @@ xf86PciProbe(void)
 		    primaryBus.id.pci = info;
 		} else {
 		    xf86Msg(X_NOTICE,
-			    "More than one possible primary device found\n");
-		    primaryBus.type ^= (BusType)(-1);
+			    "More than one possible primary device found.  Using first one seen.\n");
+                    break;
 		}
 	    }
 	}
diff --git a/hw/xfree86/common/xf86str.h b/hw/xfree86/common/xf86str.h
index b9a2e06..2b8f998 100644
--- a/hw/xfree86/common/xf86str.h
+++ b/hw/xfree86/common/xf86str.h
@@ -516,7 +516,7 @@ typedef struct _confdrirec {
 } confDRIRec, *confDRIPtr;
 
 /* These values should be adjusted when new fields are added to ScrnInfoRec */
-#define NUM_RESERVED_INTS		16
+#define NUM_RESERVED_INTS		15
 #define NUM_RESERVED_POINTERS		14
 #define NUM_RESERVED_FUNCS		11
 
@@ -788,6 +788,9 @@ typedef struct _ScrnInfoRec {
     ClockRangesPtr	clockRanges;
     int			adjustFlags;
 
+    /* -nr support */
+    int                 canDoBGNoneRoot;
+
     /*
      * These can be used when the minor ABI version is incremented.
      * The NUM_* parameters must be reduced appropriately to keep the
diff --git a/hw/xfree86/common/xisb.c b/hw/xfree86/common/xisb.c
index 1cb9e48..edb2453 100644
--- a/hw/xfree86/common/xisb.c
+++ b/hw/xfree86/common/xisb.c
@@ -98,6 +98,9 @@ XisbRead (XISBuffer *b)
 {
 	int ret;
 
+        if (b == NULL)
+            return -2;
+
 	if (b->current >= b->end)
 	{
 		if (b->block_duration >= 0)
diff --git a/hw/xfree86/ddc/interpret_edid.c b/hw/xfree86/ddc/interpret_edid.c
index 12a5254..1ace9d0 100644
--- a/hw/xfree86/ddc/interpret_edid.c
+++ b/hw/xfree86/ddc/interpret_edid.c
@@ -52,6 +52,15 @@ static void get_whitepoint_section(Uchar *, struct whitePoints *);
 static void get_detailed_timing_section(Uchar*, struct 	detailed_timings *);
 static Bool validate_version(int scrnIndex, struct edid_version *);
 
+static Bool
+is_standard_aspect_ratio(int x, int y)
+{
+    return ((x == 16 && y == 9) ||
+	    (x == 16 && y == 10) ||
+	    (x == 4 && y == 3) ||
+	    (x == 5 && y == 4));
+}
+
 static void
 handle_edid_quirks(xf86MonPtr m)
 {
@@ -92,10 +101,7 @@ handle_edid_quirks(xf86MonPtr m)
      * try to find the largest detailed timing that matches that aspect
      * ratio and use that to fill in the feature section.
      */
-    if ((m->features.hsize == 16 && m->features.vsize == 9) ||
-	(m->features.hsize == 16 && m->features.vsize == 10) ||
-	(m->features.hsize == 4 && m->features.vsize == 3) ||
-	(m->features.hsize == 5 && m->features.vsize == 4)) {
+    if (is_standard_aspect_ratio(m->features.hsize, m->features.vsize)) {
 	int real_hsize = 0, real_vsize = 0;
 	float target_aspect, timing_aspect;
 	
@@ -131,6 +137,28 @@ handle_edid_quirks(xf86MonPtr m)
 	xf86Msg(X_INFO, "Quirked EDID physical size to %dx%d cm\n",
 		m->features.hsize, m->features.vsize);
     }
+
+    /*
+     * Some monitors do the reverse, putting real size in the global block
+     * and aspect ratios in the detailed timings.  Check, but only if we
+     * think we've got a real physical size.
+     */
+    if (m->features.hsize && m->features.vsize) {
+        for (i = 0; i < 4; i++) {
+	    if (m->det_mon[i].type == DT) {
+		struct detailed_timings *timing;
+		timing = &m->det_mon[i].section.d_timings;
+
+		if (is_standard_aspect_ratio(timing->h_size, timing->v_size)) {
+                    timing->h_size = m->features.hsize * 10;
+                    timing->v_size = m->features.vsize * 10;
+	            xf86Msg(X_INFO, "Quirked timing size to %dx%d mm\n",
+		            timing->h_size, timing->v_size);
+
+                }
+	    }
+        }
+    }
 }
 
 xf86MonPtr
diff --git a/hw/xfree86/doc/man/Xorg.man.pre b/hw/xfree86/doc/man/Xorg.man.pre
index 8e86a37..d9bd624 100644
--- a/hw/xfree86/doc/man/Xorg.man.pre
+++ b/hw/xfree86/doc/man/Xorg.man.pre
@@ -109,7 +109,7 @@ script.
 .B __xservername__
 supports several mechanisms for supplying/obtaining configuration and
 run-time parameters: command line options, environment variables, the
-__xconfigfile__(__filemansuffix__) configuration file, auto-detection, and
+__xconfigfile__(__filemansuffix__) configuration files, auto-detection, and
 fallback defaults.  When the same information is supplied in more than
 one way, the highest precedence mechanism is used.  The list of mechanisms
 is ordered from highest precedence to lowest.  Note that not all parameters
@@ -176,6 +176,13 @@ This option will work for any file when the server is run as root (i.e,
 with real-uid 0), or for files relative to a directory in the config
 search path for all other users.
 .TP 8
+.BI \-configdir " directory"
+Read the server configuration files from
+.IR directory .
+This option will work for any directory when the server is run as root
+(i.e, with real-uid 0), or for directories relative to a directory in the
+config directory search path for all other users.
+.TP 8
 .B \-configure
 When this option is specified, the
 .B __xservername__
@@ -456,6 +463,10 @@ __xconfigfile__(__filemansuffix__) file option.
 .B __xservername__
 typically uses a configuration file called
 .B __xconfigfile__
+and configuration files with the suffix
+.I .conf
+in a directory called
+.B __xconfigdir__
 for its initial setup.
 Refer to the __xconfigfile__(__filemansuffix__) manual page for information
 about the format of this file.
@@ -464,7 +475,9 @@ about the format of this file.
 has a mechanism for automatically generating a built-in configuration
 at run-time when no
 .B __xconfigfile__
-file is present.  The current version of this automatic configuration
+file or
+.B __xconfigdir__
+files are present.  The current version of this automatic configuration
 mechanism works in two ways.
 .PP
 The first is via enhancements that have made many components of the
@@ -486,7 +499,7 @@ supported by __xservername__.  Enhancements are planned for future releases.
 .SH FILES
 The
 .B __xservername__
-server config file can be found in a range of locations.  These are
+server config files can be found in a range of locations.  These are
 documented fully in the __xconfigfile__(__filemansuffix__) manual page.  The
 most commonly used locations are shown here.
 .TP 30
@@ -505,6 +518,21 @@ Server configuration file.
 .B __projectroot__/lib/X11/__xconfigfile__
 Server configuration file.
 .TP 30
+.B /etc/X11/__xconfigdir__
+Server configuration directory.
+.TP 30
+.B /etc/X11/__xconfigdir__-4
+Server configuration directory.
+.TP 30
+.B /etc/__xconfigdir__
+Server configuration directory.
+.TP 30
+.B __projectroot__/etc/__xconfigdir__
+Server configuration directory.
+.TP 30
+.B __projectroot__/lib/X11/__xconfigdir__
+Server configuration directory.
+.TP 30
 .BI __logdir__/__xservername__. n .log
 Server log file for display
 .IR n .
diff --git a/hw/xfree86/doc/man/xorg.conf.man.pre b/hw/xfree86/doc/man/xorg.conf.man.pre
index f0a7373..30747d3 100644
--- a/hw/xfree86/doc/man/xorg.conf.man.pre
+++ b/hw/xfree86/doc/man/xorg.conf.man.pre
@@ -2,27 +2,35 @@
 .ds q \N'34'
 .TH __xconfigfile__ __filemansuffix__ __vendorversion__
 .SH NAME
-__xconfigfile__ \- configuration File for __xservername__ X server
+__xconfigfile__ and __xconfigdir__ \- configuration files for
+__xservername__ X server
 .SH INTRODUCTION
 .B __xservername__
 supports several mechanisms for supplying/obtaining configuration and
 run-time parameters: command line options, environment variables, the
-__xconfigfile__ configuration file, auto-detection, and fallback defaults.
-When the same information is supplied in more than one way, the highest
-precedence mechanism is used.  The list of mechanisms is ordered from
-highest precedence to lowest.  Note that not all parameters can be
-supplied via all methods.  The available command line options and
-environment variables (and some defaults) are described in the Xserver(__appmansuffix__)
-and __xservername__(__appmansuffix__) manual pages.  Most configuration file parameters, with
-their defaults, are described below.  Driver and module specific
-configuration parameters are described in the relevant driver or module
-manual page.
+__xconfigfile__ and __xconfigdir__ configuration files, auto-detection,
+and fallback defaults. When the same information is supplied in more
+than one way, the highest precedence mechanism is used. The list of
+mechanisms is ordered from highest precedence to lowest. Note that not
+all parameters can be supplied via all methods. The available command
+line options and environment variables (and some defaults) are
+described in the Xserver(__appmansuffix__) and
+__xservername__(__appmansuffix__) manual pages. Most configuration file
+parameters, with their defaults, are described below. Driver and module
+specific configuration parameters are described in the relevant driver
+or module manual page.
 .SH DESCRIPTION
 .B __xservername__
 uses a configuration file called
 .I __xconfigfile__
+and files ending in the suffix
+.I .conf
+from the directory
+.I __xconfigdir__
 for its initial setup.
-This configuration file is searched for in the following places when the
+The
+.I __xconfigfile__
+configuration file is searched for in the following places when the
 server is started as a normal user:
 .PP
 .RS 4
@@ -93,9 +101,28 @@ directory), and
 is the machine's hostname as reported by
 .BR gethostname (__libmansuffix__).
 .PP
+Additional configuration files are searched for in the following
+directories:
+.PP
+.RS 4
+.nf
+.I /etc/X11/__xconfigdir__\-4
+.I /etc/X11/__xconfigdir__
+.I /etc/__xconfigdir__
+.IR __projectroot__/etc/X11/__xconfigdir__. <hostname>
+.I __projectroot__/etc/X11/__xconfigdir__\-4
+.I __projectroot__/etc/X11/__xconfigdir__
+.IR __projectroot__/lib/X11/__xconfigdir__. <hostname>
+.I __projectroot__/lib/X11/__xconfigdir__\-4
+.I __projectroot__/lib/X11/__xconfigdir__
+.fi
+.RE
+.PP
 The
 .I __xconfigfile__
-file is composed of a number of sections which may be present in any order,
+and
+.I __xconfigdir__
+files are composed of a number of sections which may be present in any order,
 or omitted to use default configuration values.
 Each section has the form:
 .PP
@@ -117,6 +144,7 @@ The section names are:
 .BR "Module         " "Dynamic module loading"
 .BR "Extensions     " "Extension enabling"
 .BR "InputDevice    " "Input device description"
+.BR "InputClass     " "Input class description"
 .BR "Device         " "Graphics device description"
 .BR "VideoAdaptor   " "Xv video adaptor description"
 .BR "Monitor        " "Monitor description"
@@ -853,6 +881,11 @@ which are described here.
 See the individual input driver manual pages for a description of the
 device\-specific options.
 .TP 7
+.BI "Option \*qAutoServerLayout\*q  \*q" boolean \*q
+Always add the device to the ServerLayout section used by this instance of
+the server. This affects implied layouts as well as explicit layouts
+specified in the configuration and/or on the command line.
+.TP 7
 .BI "Option \*qCorePointer\*q"
 Deprecated, use
 .B SendCoreEvents
@@ -925,6 +958,143 @@ Selects the scheme, which is the underlying algorithm.
 .B  "predictable   default algorithm (behaving more predictable)"
 .B  "lightweight   old acceleration code (as specified in the X protocol spec)"
 .B  "none          no acceleration or deceleration"
+.fi
+.RE
+.TP 7
+.BI "Option \*qAccelerationNumerator\*q  \*q" integer \*q
+.TP 7
+.BI "Option \*qAccelerationDenominator\*q  \*q" integer \*q
+Set numerator and denominator of the acceleration factor. The acceleration
+factor is a rational which, together with threshold, can be used to tweak
+profiles to suit the users needs. The
+.B simple
+and
+.B limited
+profiles use it directly (i.e. they accelerate by the factor), for other
+profiles it should hold that a higher acceleration factor leads to a faster
+pointer. Typically, 1 is unaccelerated and values up to 5 are sensible.
+.TP 7
+.BI "Option \*qAccelerationThreshold\*q  \*q" integer \*q
+Set the threshold, which is roughly the velocity (usually device units per 10
+ms) required for acceleration to become effective. The precise effect varies
+with the profile however.
+
+.SH "INPUTCLASS SECTION"
+The config file may have multiple
+.B InputClass
+sections.
+These sections are optional and are used to provide configuration for a
+class of input devices as they are automatically added. An input device can
+match more than one
+.B InputClass
+section. Each class can override settings from a previous class, so it is
+best to arrange the sections with the most generic matches first.
+.PP
+.B InputClass
+sections have the following format:
+.PP
+.RS 4
+.nf
+.B  "Section \*qInputClass\*q"
+.BI "    Identifier  \*q" name \*q
+.I  "    entries"
+.I  "    ..."
+.I  "    options"
+.I  "    ..."
+.B  "EndSection"
+.fi
+.RE
+.PP
+The
+.B Identifier
+entry is required in all
+.B InputClass
+sections.
+All other entries are optional.
+.PP
+The
+.B Identifier
+entry specifies the unique name for this input class.
+The
+.B Driver
+entry specifies the name of the driver to use for this input device.
+After all classes have been examined, the
+.RI \*q inputdriver \*q
+module from the first
+.B Driver
+entry will be enabled when using the loadable server.
+.PP
+When an input device is automatically added, its characteristics are
+checked against all
+.B InputClass
+sections. Each section can contain optional entries to narrow the match
+of the class. If none of the optional entries appear, the
+.B InputClass
+section is generic and will match any input device. If more than one of
+these entries appear, they all must match for the configuration to apply.
+The allowed matching entries are shown below.
+.PP
+.TP 7
+.BI "MatchProduct  \*q" matchproduct \*q
+This entry can be used to check if the substring
+.RI \*q matchproduct \*q
+occurs in the device's product name. Multiple substrings can be matched by
+separating arguments with a '|' character.
+.TP 7
+.BI "MatchVendor  \*q" matchvendor \*q
+This entry can be used to check if the substring
+.RI \*q matchvendor \*q
+occurs in the device's vendor name. Multiple substrings can be matched by
+separating arguments with a '|' character.
+.TP 7
+.BI "MatchDevicePath \*q" matchdevice \*q
+This entry can be used to check if the device file matches the
+.RI \*q matchdevice \*q
+pathname pattern. Multiple patterns can be matched by separating arguments
+with a '|' character.
+.TP 7
+.BI "MatchTag \*q" matchtag \*q
+This entry can be used to check if tags assigned by the config backend
+matches the
+.RI \*q matchtag \*q
+pattern.  Multiple patterns can be matched by separating arguments
+with a '|' character. A match is found if at least one of the tags given in
+.RI \*q matchtag \*q
+matches at least one of the tags assigned by the backend.
+.TP 7
+.BI "MatchIsKeyboard     \*q" bool \*q
+.TP 7
+.BI "MatchIsPointer      \*q" bool \*q
+.TP 7
+.BI "MatchIsJoystick     \*q" bool \*q
+.TP 7
+.BI "MatchIsTablet       \*q" bool \*q
+.TP 7
+.BI "MatchIsTouchpad     \*q" bool \*q
+.TP 7
+.BI "MatchIsTouchscreen  \*q" bool \*q
+Match device types. These entries take a boolean argument similar to
+.B Option
+entries.
+.PP
+When an input device has been matched to the
+.B InputClass
+section, any
+.B Option
+entries are applied to the device. One
+.B InputClass
+specific
+.B Option
+is recognized. See the
+.B InputDevice
+section above for a description of the remaining
+.B Option
+entries.
+.TP 7
+.BI "Option \*qIgnore\*q \*q" boolean \*q
+This optional entry specifies that the device should be ignored entirely,
+and not added to the server. This can be useful when the device is handled
+by another program and no X events should be generated.
 .SH "DEVICE SECTION"
 The config file may have multiple
 .B Device
@@ -1557,9 +1727,7 @@ sections have the following format:
 .PP
 The
 .B Identifier
-and
-.B Device
-entries are mandatory.
+entry is mandatory.
 All others are optional.
 .PP
 The
diff --git a/hw/xfree86/modes/xf86Crtc.c b/hw/xfree86/modes/xf86Crtc.c
index 5a96e04..9c08c21 100644
--- a/hw/xfree86/modes/xf86Crtc.c
+++ b/hw/xfree86/modes/xf86Crtc.c
@@ -354,7 +354,7 @@ xf86CrtcSetModeTransform (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotati
     }
 
     /* Only upload when needed, to avoid unneeded delays. */
-    if (!crtc->active)
+    if (!crtc->active && crtc->funcs->gamma_set)
 	crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
                                             crtc->gamma_blue, crtc->gamma_size);
 
@@ -3011,6 +3011,7 @@ xf86_crtc_box_area(BoxPtr box)
     return (int) (box->x2 - box->x1) * (int) (box->y2 - box->y1);
 }
 
+#ifdef XV
 /*
  * Return the crtc covering 'box'. If two crtcs cover a portion of
  * 'box', then prefer 'desired'. If 'desired' is NULL, then prefer the crtc
@@ -3099,6 +3100,7 @@ xf86_crtc_clip_video_helper(ScrnInfoPtr pScrn,
 
     return ret;
 }
+#endif
 
 xf86_crtc_notify_proc_ptr
 xf86_wrap_crtc_notify (ScreenPtr screen, xf86_crtc_notify_proc_ptr new)
diff --git a/hw/xfree86/modes/xf86Crtc.h b/hw/xfree86/modes/xf86Crtc.h
index 68a968c..f2abb74 100644
--- a/hw/xfree86/modes/xf86Crtc.h
+++ b/hw/xfree86/modes/xf86Crtc.h
@@ -934,6 +934,7 @@ xf86_hide_cursors (ScrnInfoPtr scrn);
 extern _X_EXPORT void
 xf86_cursors_fini (ScreenPtr screen);
 
+#ifdef XV
 /*
  * For overlay video, compute the relevant CRTC and
  * clip video to that.
@@ -952,6 +953,7 @@ xf86_crtc_clip_video_helper(ScrnInfoPtr pScrn,
 			    RegionPtr   reg,
 			    INT32	width,
 			    INT32	height);
+#endif
     
 extern _X_EXPORT xf86_crtc_notify_proc_ptr
 xf86_wrap_crtc_notify (ScreenPtr pScreen, xf86_crtc_notify_proc_ptr new);
diff --git a/hw/xfree86/modes/xf86Cursors.c b/hw/xfree86/modes/xf86Cursors.c
index 385848b..d6e747f 100644
--- a/hw/xfree86/modes/xf86Cursors.c
+++ b/hw/xfree86/modes/xf86Cursors.c
@@ -611,7 +611,7 @@ xf86_reload_cursors (ScreenPtr screen)
     cursor_screen_priv = dixLookupPrivate(&screen->devPrivates,
 					  xf86CursorScreenKey);
     /* return if HW cursor is inactive, to avoid displaying two cursors */
-    if (!cursor_screen_priv->isUp)
+    if (!cursor_screen_priv || !cursor_screen_priv->isUp)
 	return;
 
     scrn = xf86Screens[screen->myNum];
diff --git a/hw/xfree86/modes/xf86EdidModes.c b/hw/xfree86/modes/xf86EdidModes.c
index b057d7d..2232434 100644
--- a/hw/xfree86/modes/xf86EdidModes.c
+++ b/hw/xfree86/modes/xf86EdidModes.c
@@ -175,6 +175,11 @@ static Bool quirk_detailed_v_in_cm (int scrnIndex, xf86MonPtr DDC)
 	DDC->vendor.prod_id == 1157)
 	return TRUE;
 
+    /* LP #380009: HP Compaq NC8430 LP154W01-TLA8 */
+    if (memcmp (DDC->vendor.name, "LPL", 4) == 0 &&
+        DDC->vendor.prod_id == 5750)
+        return TRUE;
+
     return FALSE;
 }
 
diff --git a/hw/xfree86/modes/xf86RandR12.c b/hw/xfree86/modes/xf86RandR12.c
index 7ba09b6..2c783d9 100644
--- a/hw/xfree86/modes/xf86RandR12.c
+++ b/hw/xfree86/modes/xf86RandR12.c
@@ -946,7 +946,8 @@ xf86RandR12SetRotations (ScreenPtr pScreen, Rotation rotations)
     for (c = 0; c < config->num_crtc; c++) {
 	xf86CrtcPtr    crtc = config->crtc[c];
 
-	RRCrtcSetRotations (crtc->randr_crtc, rotations);
+        if (crtc != NULL)
+            RRCrtcSetRotations (crtc->randr_crtc, rotations);
     }
 #endif
     randrp->supported_rotations = rotations;
diff --git a/hw/xfree86/os-support/hurd/hurd_video.c b/hw/xfree86/os-support/hurd/hurd_video.c
index 4a99db3..e049ceb 100644
--- a/hw/xfree86/os-support/hurd/hurd_video.c
+++ b/hw/xfree86/os-support/hurd/hurd_video.c
@@ -124,8 +124,6 @@ xf86EnableIO()
 	FatalError("xf86EnableIO: ioperm() failed (%s)\n", strerror(errno));
 	return FALSE;
     }
-    ioperm(0x40,4,0); /* trap access to the timer chip */
-    ioperm(0x60,4,0); /* trap access to the keyboard controller */
     return TRUE;
 }
 	
diff --git a/hw/xfree86/os-support/linux/lnx_init.c b/hw/xfree86/os-support/linux/lnx_init.c
index f84c614..11b36f5 100644
--- a/hw/xfree86/os-support/linux/lnx_init.c
+++ b/hw/xfree86/os-support/linux/lnx_init.c
@@ -43,6 +43,7 @@ static Bool KeepTty = FALSE;
 static int VTnum = -1;
 static Bool VTSwitch = TRUE;
 static Bool ShareVTs = FALSE;
+Bool NoHwAccess = FALSE;
 static int activeVT = -1;
 
 static int vtPermSave[4];
@@ -353,10 +354,25 @@ xf86CloseConsole(void)
 
     if (VTSwitch)
     {
+        struct vt_stat vts;
+
         /*
-         * Perform a switch back to the active VT when we were started
+         * Perform a switch back to the active VT when we were started.
+         * We cannot rely on vtSema to determine if the server was the
+         * active VT at the time of shutdown since it has already been
+         * released.  Instead, we manually check the current VT and
+         * compare it with the VT we were running on.
          */
-        if (activeVT >= 0) {
+        if (ioctl(xf86Info.consoleFd, VT_GETSTATE, &vts) < 0)
+        {
+            /* If this failed, fall back to old behaviour
+             * of always switching. */
+            xf86Msg(X_WARNING,"xf86OpenConsole: VT_GETSTATE failed: %s\n",
+                    strerror(errno));
+            vts.v_active = xf86Info.vtno;
+        }
+
+        if (activeVT >= 0 && vts.v_active == xf86Info.vtno) {
 	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, activeVT) < 0)
 	        xf86Msg(X_WARNING, "xf86CloseConsole: VT_ACTIVATE failed: %s\n",
 		        strerror(errno));
@@ -402,6 +418,11 @@ xf86ProcessArgument(int argc, char *argv[], int i)
                 ShareVTs = TRUE;
                 return(1);
         }
+	if (!strcmp(argv[i], "-nohwaccess"))
+	{
+		NoHwAccess = TRUE;
+		return(1);
+	}
 	if ((argv[i][0] == 'v') && (argv[i][1] == 't'))
 	{
 		if (sscanf(argv[i], "vt%2d", &VTnum) == 0)
@@ -423,5 +444,6 @@ xf86UseMsg(void)
 	ErrorF("don't detach controlling tty (for debugging only)\n");
         ErrorF("-novtswitch            don't immediately switch to new VT\n");
         ErrorF("-sharevts              share VTs with another X server\n");
+	ErrorF("-nohwaccess            don't access hardware ports directly\n");
 	return;
 }
diff --git a/hw/xfree86/os-support/linux/lnx_video.c b/hw/xfree86/os-support/linux/lnx_video.c
index 73409df..bd5f274 100644
--- a/hw/xfree86/os-support/linux/lnx_video.c
+++ b/hw/xfree86/os-support/linux/lnx_video.c
@@ -51,6 +51,7 @@
 #define MAP_FAILED ((void *)-1)
 #endif
 
+extern Bool NoHwAccess;
 static Bool ExtendedEnabled = FALSE;
 
 #ifdef __ia64__
@@ -501,6 +502,9 @@ xf86EnableIO(void)
 	int fd;
 	unsigned int ioBase_phys;
 #endif
+	/* Fake it... */
+	if (NoHwAccess)
+		return TRUE;
 
 	if (ExtendedEnabled)
 		return TRUE;
diff --git a/hw/xfree86/parser/Configint.h b/hw/xfree86/parser/Configint.h
index cdc7be8..03509b3 100644
--- a/hw/xfree86/parser/Configint.h
+++ b/hw/xfree86/parser/Configint.h
@@ -148,6 +148,8 @@ else\
 "The %s keyword requires a number to follow it."
 #define POSITIVE_INT_MSG \
 "The %s keyword requires a positive integer to follow it."
+#define BOOL_MSG \
+"The %s keyword requires a boolean to follow it."
 #define ZAXISMAPPING_MSG \
 "The ZAxisMapping keyword requires 2 positive numbers or X or Y to follow it."
 #define AUTOREPEAT_MSG \
diff --git a/hw/xfree86/parser/InputClass.c b/hw/xfree86/parser/InputClass.c
new file mode 100644
index 0000000..7fb2866
--- /dev/null
+++ b/hw/xfree86/parser/InputClass.c
@@ -0,0 +1,288 @@
+/*
+ * Copyright (c) 2009 Dan Nicholson
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* View/edit this file with tab stops set to 4 */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <string.h>
+#include "os.h"
+#include "xf86Parser.h"
+#include "xf86tokens.h"
+#include "Configint.h"
+
+extern LexRec val;
+
+static
+xf86ConfigSymTabRec InputClassTab[] =
+{
+    {ENDSECTION, "endsection"},
+    {IDENTIFIER, "identifier"},
+    {OPTION, "option"},
+    {DRIVER, "driver"},
+    {MATCH_PRODUCT, "matchproduct"},
+    {MATCH_VENDOR, "matchvendor"},
+    {MATCH_DEVICE_PATH, "matchdevicepath"},
+    {MATCH_TAG, "matchtag"},
+    {MATCH_IS_KEYBOARD, "matchiskeyboard"},
+    {MATCH_IS_POINTER, "matchispointer"},
+    {MATCH_IS_JOYSTICK, "matchisjoystick"},
+    {MATCH_IS_TABLET, "matchistablet"},
+    {MATCH_IS_TOUCHPAD, "matchistouchpad"},
+    {MATCH_IS_TOUCHSCREEN, "matchistouchscreen"},
+    {-1, ""},
+};
+
+#define CLEANUP xf86freeInputClassList
+
+#define TOKEN_SEP "|"
+
+XF86ConfInputClassPtr
+xf86parseInputClassSection(void)
+{
+    int has_ident = FALSE;
+    int token;
+
+    parsePrologue(XF86ConfInputClassPtr, XF86ConfInputClassRec)
+
+    while ((token = xf86getToken(InputClassTab)) != ENDSECTION) {
+        switch (token) {
+        case COMMENT:
+            ptr->comment = xf86addComment(ptr->comment, val.str);
+            break;
+        case IDENTIFIER:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "Identifier");
+            if (has_ident == TRUE)
+                Error(MULTIPLE_MSG, "Identifier");
+            ptr->identifier = val.str;
+            has_ident = TRUE;
+            break;
+        case DRIVER:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "Driver");
+            if (strcmp(val.str, "keyboard") == 0)
+                ptr->driver = "kbd";
+            else
+                ptr->driver = val.str;
+            break;
+        case OPTION:
+            ptr->option_lst = xf86parseOption(ptr->option_lst);
+            break;
+        case MATCH_PRODUCT:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchProduct");
+            ptr->match_product = xstrtokenize(val.str, TOKEN_SEP);
+            break;
+        case MATCH_VENDOR:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchVendor");
+            ptr->match_vendor = xstrtokenize(val.str, TOKEN_SEP);
+            break;
+        case MATCH_DEVICE_PATH:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchDevicePath");
+            ptr->match_device = xstrtokenize(val.str, TOKEN_SEP);
+            break;
+        case MATCH_TAG:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchTag");
+            ptr->match_tag = xstrtokenize(val.str, TOKEN_SEP);
+            break;
+        case MATCH_IS_KEYBOARD:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchIsKeyboard");
+            ptr->is_keyboard.set = xf86getBoolValue(&ptr->is_keyboard.val,
+                                                    val.str);
+            if (!ptr->is_keyboard.set)
+                Error(BOOL_MSG, "MatchIsKeyboard");
+            break;
+        case MATCH_IS_POINTER:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchIsPointer");
+            ptr->is_pointer.set = xf86getBoolValue(&ptr->is_pointer.val,
+                                                   val.str);
+            if (!ptr->is_pointer.set)
+                Error(BOOL_MSG, "MatchIsPointer");
+            break;
+        case MATCH_IS_JOYSTICK:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchIsJoystick");
+            ptr->is_joystick.set = xf86getBoolValue(&ptr->is_joystick.val,
+                                                    val.str);
+            if (!ptr->is_joystick.set)
+                Error(BOOL_MSG, "MatchIsJoystick");
+            break;
+        case MATCH_IS_TABLET:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchIsTablet");
+            ptr->is_tablet.set = xf86getBoolValue(&ptr->is_tablet.val,
+                                                  val.str);
+            if (!ptr->is_tablet.set)
+                Error(BOOL_MSG, "MatchIsTablet");
+            break;
+        case MATCH_IS_TOUCHPAD:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchIsTouchpad");
+            ptr->is_touchpad.set = xf86getBoolValue(&ptr->is_touchpad.val,
+                                                    val.str);
+            if (!ptr->is_touchpad.set)
+                Error(BOOL_MSG, "MatchIsTouchpad");
+            break;
+        case MATCH_IS_TOUCHSCREEN:
+            if (xf86getSubToken(&(ptr->comment)) != STRING)
+                Error(QUOTE_MSG, "MatchIsTouchscreen");
+            ptr->is_touchscreen.set = xf86getBoolValue(&ptr->is_touchscreen.val,
+                                                       val.str);
+            if (!ptr->is_touchscreen.set)
+                Error(BOOL_MSG, "MatchIsTouchscreen");
+            break;
+        case EOF_TOKEN:
+            Error(UNEXPECTED_EOF_MSG, NULL);
+            break;
+        default:
+            Error(INVALID_KEYWORD_MSG, xf86tokenString ());
+            break;
+        }
+    }
+
+    if (!has_ident)
+        Error(NO_IDENT_MSG, NULL);
+
+#ifdef DEBUG
+    printf("InputClass section parsed\n");
+#endif
+
+    return ptr;
+}
+
+void
+xf86printInputClassSection (FILE * cf, XF86ConfInputClassPtr ptr)
+{
+    char **list;
+
+    while (ptr) {
+        fprintf(cf, "Section \"InputClass\"\n");
+        if (ptr->comment)
+            fprintf(cf, "%s", ptr->comment);
+        if (ptr->identifier)
+            fprintf(cf, "\tIdentifier      \"%s\"\n", ptr->identifier);
+        if (ptr->driver)
+            fprintf(cf, "\tDriver          \"%s\"\n", ptr->driver);
+        if (ptr->match_product) {
+            fprintf(cf, "\tMatchProduct    \"");
+            for (list = ptr->match_product; *list; list++)
+                fprintf(cf, "%s%s",
+                        list == ptr->match_product ? "" : TOKEN_SEP,
+                        *list);
+            fprintf(cf, "\"\n");
+        }
+        if (ptr->match_vendor) {
+            fprintf(cf, "\tMatchVendor     \"");
+            for (list = ptr->match_vendor; *list; list++)
+                fprintf(cf, "%s%s",
+                        list == ptr->match_vendor ? "" : TOKEN_SEP,
+                        *list);
+            fprintf(cf, "\"\n");
+        }
+        if (ptr->match_device) {
+            fprintf(cf, "\tMatchDevicePath \"");
+            for (list = ptr->match_device; *list; list++)
+                fprintf(cf, "%s%s",
+                        list == ptr->match_device ? "" : TOKEN_SEP,
+                        *list);
+            fprintf(cf, "\"\n");
+        }
+        if (ptr->match_tag) {
+            fprintf(cf, "\tMatchTag \"");
+            for (list = ptr->match_tag; *list; list++)
+                fprintf(cf, "%s%s",
+                        list == ptr->match_tag ? "" : TOKEN_SEP,
+                        *list);
+            fprintf(cf, "\"\n");
+        }
+        if (ptr->is_keyboard.set)
+            fprintf(cf, "\tIsKeyboard      \"%s\"\n",
+                    ptr->is_keyboard.val ? "yes" : "no");
+        if (ptr->is_pointer.set)
+            fprintf(cf, "\tIsPointer       \"%s\"\n",
+                    ptr->is_pointer.val ? "yes" : "no");
+        if (ptr->is_joystick.set)
+            fprintf(cf, "\tIsJoystick      \"%s\"\n",
+                    ptr->is_joystick.val ? "yes" : "no");
+        if (ptr->is_tablet.set)
+            fprintf(cf, "\tIsTablet        \"%s\"\n",
+                    ptr->is_tablet.val ? "yes" : "no");
+        if (ptr->is_touchpad.set)
+            fprintf(cf, "\tIsTouchpad      \"%s\"\n",
+                    ptr->is_touchpad.val ? "yes" : "no");
+        if (ptr->is_touchscreen.set)
+            fprintf(cf, "\tIsTouchscreen   \"%s\"\n",
+                    ptr->is_touchscreen.val ? "yes" : "no");
+        xf86printOptionList(cf, ptr->option_lst, 1);
+        fprintf(cf, "EndSection\n\n");
+        ptr = ptr->list.next;
+    }
+}
+
+void
+xf86freeInputClassList (XF86ConfInputClassPtr ptr)
+{
+    XF86ConfInputClassPtr prev;
+    char **list;
+
+    while (ptr) {
+        TestFree(ptr->identifier);
+        TestFree(ptr->driver);
+        if (ptr->match_product) {
+            for (list = ptr->match_product; *list; list++)
+                free(*list);
+            free(ptr->match_product);
+        }
+        if (ptr->match_vendor) {
+            for (list = ptr->match_vendor; *list; list++)
+                free(*list);
+            free(ptr->match_vendor);
+        }
+        if (ptr->match_device) {
+            for (list = ptr->match_device; *list; list++)
+                free(*list);
+            free(ptr->match_device);
+        }
+        if (ptr->match_tag) {
+            for (list = ptr->match_tag; *list; list++)
+                free(*list);
+            free(ptr->match_tag);
+        }
+        TestFree(ptr->comment);
+        xf86optionListFree(ptr->option_lst);
+
+        prev = ptr;
+        ptr = ptr->list.next;
+        free(prev);
+    }
+}
diff --git a/hw/xfree86/parser/Layout.c b/hw/xfree86/parser/Layout.c
index d548cd2..2100e9e 100644
--- a/hw/xfree86/parser/Layout.c
+++ b/hw/xfree86/parser/Layout.c
@@ -64,6 +64,10 @@
 #include "Configint.h"
 #include <string.h>
 
+
+/* Needed for auto server layout */
+extern int xf86CheckBoolOption(void* optlist, const char *name, int deflt);
+
 extern LexRec val;
 
 static xf86ConfigSymTabRec LayoutTab[] =
@@ -450,15 +454,67 @@ else \
 }
 
 int
+xf86layoutAddInputDevices(XF86ConfigPtr config, XF86ConfLayoutPtr layout)
+{
+    int count = 0;
+    XF86ConfInputPtr input = config->conf_input_lst;
+    XF86ConfInputrefPtr inptr;
+
+    /* add all AutoServerLayout devices to the server layout */
+    while (input)
+    {
+	if (xf86CheckBoolOption(input->inp_option_lst, "AutoServerLayout", FALSE))
+	{
+	    XF86ConfInputrefPtr iref = layout->lay_input_lst;
+
+	    /* avoid duplicates if referenced but lists AutoServerLayout too */
+	    while (iref)
+	    {
+		if (strcmp(iref->iref_inputdev_str, input->inp_identifier) == 0)
+		    break;
+		iref = iref->list.next;
+	    }
+
+	    if (!iref)
+	    {
+		XF86ConfInputrefPtr iptr;
+		iptr = calloc(1, sizeof(XF86ConfInputrefRec));
+		iptr->iref_inputdev_str = input->inp_identifier;
+		layout->lay_input_lst = (XF86ConfInputrefPtr)
+		    xf86addListItem((glp)layout->lay_input_lst, (glp)iptr);
+		count++;
+	    }
+	}
+	input = input->list.next;
+    }
+
+    inptr = layout->lay_input_lst;
+    while (inptr)
+    {
+	input = xf86findInput (inptr->iref_inputdev_str,
+		config->conf_input_lst);
+	if (!input)
+	{
+	    xf86validationError (UNDEFINED_INPUT_MSG,
+		    inptr->iref_inputdev_str, layout->lay_identifier);
+	    return -1;
+	}
+	else
+	    inptr->iref_inputdev = input;
+	inptr = inptr->list.next;
+    }
+
+    return count;
+}
+
+int
 xf86validateLayout (XF86ConfigPtr p)
 {
 	XF86ConfLayoutPtr layout = p->conf_layout_lst;
 	XF86ConfAdjacencyPtr adj;
 	XF86ConfInactivePtr iptr;
-	XF86ConfInputrefPtr inptr;
 	XF86ConfScreenPtr screen;
 	XF86ConfDevicePtr device;
-	XF86ConfInputPtr input;
 
 	while (layout)
 	{
@@ -500,21 +556,10 @@ xf86validateLayout (XF86ConfigPtr p)
 				iptr->inactive_device = device;
 			iptr = iptr->list.next;
 		}
-		inptr = layout->lay_input_lst;
-		while (inptr)
-		{
-			input = xf86findInput (inptr->iref_inputdev_str,
-									p->conf_input_lst);
-			if (!input)
-			{
-				xf86validationError (UNDEFINED_INPUT_MSG,
-						inptr->iref_inputdev_str, layout->lay_identifier);
-				return (FALSE);
-			}
-			else
-				inptr->iref_inputdev = input;
-			inptr = inptr->list.next;
-		}
+
+		if (xf86layoutAddInputDevices(p, layout) == -1)
+		    return FALSE;
+
 		layout = layout->list.next;
 	}
 	return (TRUE);
diff --git a/hw/xfree86/parser/Makefile.am b/hw/xfree86/parser/Makefile.am
index b8fab28..49c191f 100644
--- a/hw/xfree86/parser/Makefile.am
+++ b/hw/xfree86/parser/Makefile.am
@@ -13,6 +13,7 @@ INTERNAL_SOURCES= \
 	Files.c \
 	Flags.c \
 	Input.c \
+	InputClass.c \
 	Layout.c \
 	Module.c \
 	Video.c \
diff --git a/hw/xfree86/parser/configProcs.h b/hw/xfree86/parser/configProcs.h
index 26ba40e..7d8a8e5 100644
--- a/hw/xfree86/parser/configProcs.h
+++ b/hw/xfree86/parser/configProcs.h
@@ -48,6 +48,10 @@ XF86ConfInputPtr xf86parseInputSection(void);
 void xf86printInputSection(FILE *f, XF86ConfInputPtr ptr);
 void xf86freeInputList(XF86ConfInputPtr ptr);
 int xf86validateInput (XF86ConfigPtr p);
+/* InputClass.c */
+XF86ConfInputClassPtr xf86parseInputClassSection(void);
+void xf86printInputClassSection(FILE *f, XF86ConfInputClassPtr ptr);
+void xf86freeInputClassList(XF86ConfInputClassPtr ptr);
 /* Layout.c */
 XF86ConfLayoutPtr xf86parseLayoutSection(void);
 void xf86printLayoutSection(FILE *cf, XF86ConfLayoutPtr ptr);
diff --git a/hw/xfree86/parser/read.c b/hw/xfree86/parser/read.c
index e965d20..1091be5 100644
--- a/hw/xfree86/parser/read.c
+++ b/hw/xfree86/parser/read.c
@@ -177,6 +177,14 @@ xf86readConfigFile (void)
 				HANDLE_LIST (conf_input_lst, xf86parseInputSection,
 							 XF86ConfInputPtr);
 			}
+			else if (xf86nameCompare(val.str, "inputclass") == 0)
+			{
+				free(val.str);
+				val.str = NULL;
+				HANDLE_LIST (conf_inputclass_lst,
+						xf86parseInputClassSection,
+						XF86ConfInputClassPtr);
+			}
 			else if (xf86nameCompare (val.str, "module") == 0)
 			{
 				free(val.str);
diff --git a/hw/xfree86/parser/scan.c b/hw/xfree86/parser/scan.c
index d2e8b6d..cdca9ca 100644
--- a/hw/xfree86/parser/scan.c
+++ b/hw/xfree86/parser/scan.c
@@ -62,8 +62,11 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/types.h>
+#include <dirent.h>
 #include <unistd.h>
 #include <stdarg.h>
+#include <X11/Xdefs.h>
 #include <X11/Xfuncproto.h>
 
 #if defined(_POSIX_SOURCE)
@@ -90,17 +93,24 @@
 #include "xf86tokens.h"
 
 #define CONFIG_BUF_LEN     1024
+#define CONFIG_MAX_FILES   64
 
 static int StringToToken (char *, xf86ConfigSymTabRec *);
 
-static FILE *configFile = NULL;
+static struct {
+	FILE *file;
+	char *path;
+} configFiles[CONFIG_MAX_FILES];
 static const char **builtinConfig = NULL;
 static int builtinIndex = 0;
 static int configPos = 0;		/* current readers position */
 static int configLineNo = 0;	/* linenumber */
 static char *configBuf, *configRBuf;	/* buffer for lines */
 static char *configPath;		/* path to config file */
+static char *configDirPath;		/* path to config dir */
 static char *configSection = NULL;	/* name of current section being parsed */
+static int numFiles = 0;		/* number of config files */
+static int curFileIndex = 0;		/* index of current config file */
 static int pushToken = LOCK_TOKEN;
 static int eol_seen = 0;		/* private state to handle comments */
 LexRec val;
@@ -155,7 +165,7 @@ xf86strToUL (char *str)
 /*
  * xf86getNextLine --
  *
- *  read from the configFile FILE stream until we encounter a new
+ *  read from the configFiles FILE stream until we encounter a new
  *  line; this is effectively just a big wrapper for fgets(3).
  *
  *  xf86getToken() assumes that we will read up to the next
@@ -213,9 +223,20 @@ xf86getNextLine(void)
 	/* read in another block of chars */
 
 	do {
-		ret = fgets(configBuf + pos, configBufLen - pos - 1, configFile);
+		ret = fgets(configBuf + pos, configBufLen - pos - 1,
+			    configFiles[curFileIndex].file);
 
-		if (!ret) break;
+		if (!ret) {
+			/*
+			 * if the file doesn't end in a newline, add one
+			 * and trigger another read
+			 */
+			if (pos != 0) {
+				strcpy(&configBuf[pos], "\n");
+				ret = configBuf;
+			} else
+				break;
+		}
 
 		/* search for EOL in the new block of chars */
 
@@ -306,7 +327,7 @@ again:
 		if (!c)
 		{
 			char *ret;
-			if (configFile)
+			if (numFiles > 0)
 				ret = xf86getNextLine();
 			else {
 				if (builtinConfig[builtinIndex] == NULL)
@@ -319,7 +340,17 @@ again:
 			}
 			if (ret == NULL)
 			{
-				return (pushToken = EOF_TOKEN);
+				/*
+				 * if necessary, move to the next file and
+				 * read the first line
+				 */
+				if (curFileIndex + 1 < numFiles) {
+					curFileIndex++;
+					configLineNo = 0;
+					goto again;
+				}
+				else
+					return (pushToken = EOF_TOKEN);
 			}
 			configLineNo++;
 			configPos = 0;
@@ -575,6 +606,12 @@ xf86pathIsSafe(const char *path)
 #ifndef XCONFIGFILE
 #define XCONFIGFILE	"xorg.conf"
 #endif
+#ifndef XCONFIGDIR
+#define XCONFIGDIR	"xorg.conf.d"
+#endif
+#ifndef XCONFIGSUFFIX
+#define XCONFIGSUFFIX	".conf"
+#endif
 #ifndef PROJECTROOT
 #define PROJECTROOT	"/usr/X11R6"
 #endif
@@ -616,7 +653,8 @@ xf86pathIsSafe(const char *path)
 
 static char *
 DoSubstitution(const char *template, const char *cmdline, const char *projroot,
-				int *cmdlineUsed, int *envUsed, char *XConfigFile)
+				int *cmdlineUsed, int *envUsed,
+				const char *XConfigFile)
 {
 	char *result;
 	int i, l;
@@ -745,7 +783,164 @@ DoSubstitution(const char *template, const char *cmdline, const char *projroot,
 	return result;
 }
 
-/* 
+/*
+ * Given some searching parameters, locate and open the xorg config file.
+ */
+static char *
+OpenConfigFile(const char *path, const char *cmdline, const char *projroot,
+	       const char *confname)
+{
+	char *filepath = NULL;
+	char *pathcopy;
+	const char *template;
+	int cmdlineUsed = 0;
+	FILE *file = NULL;
+
+	pathcopy = strdup(path);
+	for (template = strtok(pathcopy, ","); template && !file;
+	     template = strtok(NULL, ",")) {
+		filepath = DoSubstitution(template, cmdline, projroot,
+					  &cmdlineUsed, NULL, confname);
+		if (!filepath)
+			continue;
+		if (cmdline && !cmdlineUsed) {
+			free(filepath);
+			filepath = NULL;
+			continue;
+		}
+		file = fopen(filepath, "r");
+		if (!file) {
+			free(filepath);
+			filepath = NULL;
+		}
+	}
+
+	if (file) {
+		configFiles[numFiles].file = file;
+		configFiles[numFiles].path = strdup(filepath);
+		numFiles++;
+	}
+	return filepath;
+}
+
+/*
+ * Match non-hidden files in the xorg config directory with a .conf
+ * suffix. This filter is passed to scandir(3).
+ */
+static int
+ConfigFilter(const struct dirent *de)
+{
+	const char *name = de->d_name;
+	size_t len = strlen(name);
+	size_t suflen = strlen(XCONFIGSUFFIX);
+
+	if (!name || name[0] == '.' || len <= suflen)
+		return 0;
+	if (strcmp(&name[len-suflen], XCONFIGSUFFIX) != 0)
+		return 0;
+	return 1;
+}
+
+static Bool
+AddConfigDirFiles(const char *dirpath, struct dirent **list, int num)
+{
+	int i;
+	Bool openedFile = FALSE;
+	Bool warnOnce = FALSE;
+
+	for (i = 0; i < num; i++) {
+		char *path;
+		FILE *file;
+
+		if (numFiles >= CONFIG_MAX_FILES) {
+			if (!warnOnce) {
+				ErrorF("Maximum number of configuration "
+				       "files opened\n");
+				warnOnce = TRUE;
+			}
+			free(list[i]);
+			continue;
+		}
+
+		path = malloc(PATH_MAX + 1);
+		snprintf(path, PATH_MAX + 1, "%s/%s", dirpath,
+			 list[i]->d_name);
+		free(list[i]);
+		file = fopen(path, "r");
+		if (!file) {
+			free(path);
+			continue;
+		}
+		openedFile = TRUE;
+
+		configFiles[numFiles].file = file;
+		configFiles[numFiles].path = path;
+		numFiles++;
+	}
+
+	return openedFile;
+}
+
+/*
+ * Given some searching parameters, locate and open the xorg config
+ * directory. The directory does not need to contain config files.
+ */
+static char *
+OpenConfigDir(const char *path, const char *cmdline, const char *projroot,
+	      const char *confname)
+{
+	char *dirpath, *pathcopy;
+	const char *template;
+	Bool found = FALSE;
+	int cmdlineUsed = 0;
+
+	pathcopy = strdup(path);
+	for (template = strtok(pathcopy, ","); template && !found;
+	     template = strtok(NULL, ",")) {
+		struct dirent **list = NULL;
+		int num;
+
+		dirpath = DoSubstitution(template, cmdline, projroot,
+					 &cmdlineUsed, NULL, confname);
+		if (!dirpath)
+			continue;
+		if (cmdline && !cmdlineUsed) {
+			free(dirpath);
+			dirpath = NULL;
+			continue;
+		}
+
+		/* match files named *.conf */
+		num = scandir(dirpath, &list, ConfigFilter, alphasort);
+		found = AddConfigDirFiles(dirpath, list, num);
+		if (!found) {
+			free(dirpath);
+			dirpath = NULL;
+			if (list)
+				free(list);
+		}
+	}
+
+	return dirpath;
+}
+
+/*
+ * xf86initConfigFiles -- Setup global variables and buffers.
+ */
+void
+xf86initConfigFiles(void)
+{
+	curFileIndex = 0;
+	configPos = 0;
+	configLineNo = 0;
+	pushToken = LOCK_TOKEN;
+
+	configBuf = malloc(CONFIG_BUF_LEN);
+	configRBuf = malloc(CONFIG_BUF_LEN);
+	configBuf[0] = '\0';	/* sanity ... */
+}
+
+/*
  * xf86openConfigFile --
  *
  * This function take a config file search path (optional), a command-line
@@ -758,7 +953,7 @@ DoSubstitution(const char *template, const char *cmdline, const char *projroot,
  * opened.  When no file is found, the return value is NULL.
  *
  * The escape sequences allowed in the search path are defined above.
- *  
+ *
  */
 
 #ifndef DEFAULT_CONF_PATH
@@ -780,117 +975,90 @@ DoSubstitution(const char *template, const char *cmdline, const char *projroot,
 const char *
 xf86openConfigFile(const char *path, const char *cmdline, const char *projroot)
 {
-	char *pathcopy;
-	const char *template;
-	int cmdlineUsed = 0;
-
-	configFile = NULL;
-	configPos = 0;		/* current readers position */
-	configLineNo = 0;	/* linenumber */
-	pushToken = LOCK_TOKEN;
-
 	if (!path || !path[0])
 		path = DEFAULT_CONF_PATH;
-	pathcopy = malloc(strlen(path) + 1);
-	strcpy(pathcopy, path);
 	if (!projroot || !projroot[0])
 		projroot = PROJECTROOT;
 
-	template = strtok(pathcopy, ",");
-
-	/* First, search for a config file. */
-	while (template && !configFile) {
-		if ((configPath = DoSubstitution(template, cmdline, projroot,
-						 &cmdlineUsed, NULL,
-						 XCONFIGFILE))) {
-			if ((configFile = fopen(configPath, "r")) != 0) {
-				if (cmdline && !cmdlineUsed) {
-					fclose(configFile);
-					configFile = NULL;
-				}
-			}
-		}
-		if (configPath && !configFile) {
-			free(configPath);
-			configPath = NULL;
-		}
-		template = strtok(NULL, ",");
-	}
-	
-	/* Then search for fallback */
-	if (!configFile) {
-	    strcpy(pathcopy, path);
-	    template = strtok(pathcopy, ",");
-
-	    while (template && !configFile) {
-		if ((configPath = DoSubstitution(template, cmdline, projroot,
-						 &cmdlineUsed, NULL,
-						 XFREE86CFGFILE))) {
-		    if ((configFile = fopen(configPath, "r")) != 0) {
-			if (cmdline && !cmdlineUsed) {
-			    fclose(configFile);
-			    configFile = NULL;
-			}
-		    }
-		}
-		if (configPath && !configFile) {
-		    free(configPath);
-		    configPath = NULL;
-		}
-		template = strtok(NULL, ",");
-	    }
-	}
-	
-	free(pathcopy);
-	if (!configFile) {
-
-		return NULL;
-	}
+	/* Search for a config file or a fallback */
+	configPath = OpenConfigFile(path, cmdline, projroot, XCONFIGFILE);
+	if (!configPath)
+		configPath = OpenConfigFile(path, cmdline, projroot,
+					    XFREE86CFGFILE);
+	return configPath;
+}
 
-	configBuf = malloc (CONFIG_BUF_LEN);
-	configRBuf = malloc (CONFIG_BUF_LEN);
-	configBuf[0] = '\0';		/* sanity ... */
+/*
+ * xf86openConfigDirFiles --
+ *
+ * This function take a config directory search path (optional), a
+ * command-line specified directory name (optional) and the ProjectRoot path
+ * (optional) and locates and opens a config directory based on that
+ * information.  If a command-line name is specified, then this function
+ * fails if it is not found.
+ *
+ * The return value is a pointer to the actual name of the direcoty that was
+ * opened.  When no directory is found, the return value is NULL.
+ *
+ * The escape sequences allowed in the search path are defined above.
+ *
+ */
+const char *
+xf86openConfigDirFiles(const char *path, const char *cmdline,
+		       const char *projroot)
+{
+	if (!path || !path[0])
+		path = DEFAULT_CONF_PATH;
+	if (!projroot || !projroot[0])
+		projroot = PROJECTROOT;
 
-	return configPath;
+	/* Search for the multiconf directory */
+	configDirPath = OpenConfigDir(path, cmdline, projroot, XCONFIGDIR);
+	return configDirPath;
 }
 
 void
 xf86closeConfigFile (void)
 {
+	int i;
+
 	free (configPath);
 	configPath = NULL;
+	free (configDirPath);
+	configDirPath = NULL;
 	free (configRBuf);
 	configRBuf = NULL;
 	free (configBuf);
 	configBuf = NULL;
 
-	if (configFile) {
-		fclose (configFile);
-		configFile = NULL;
-	} else {
+	if (numFiles == 0) {
 		builtinConfig = NULL;
 		builtinIndex = 0;
 	}
+	for (i = 0; i < numFiles; i++) {
+		fclose(configFiles[i].file);
+		configFiles[i].file = NULL;
+		free(configFiles[i].path);
+		configFiles[i].path = NULL;
+	}
+	numFiles = 0;
 }
 
 void
 xf86setBuiltinConfig(const char *config[])
 {
 	builtinConfig = config;
-	configPath = strdup("<builtin configuration>");
-	configBuf = malloc (CONFIG_BUF_LEN);
-	configRBuf = malloc (CONFIG_BUF_LEN);
-	configBuf[0] = '\0';		/* sanity ... */
-
 }
 
 void
 xf86parseError (char *format,...)
 {
 	va_list ap;
+	char *filename = numFiles ? configFiles[curFileIndex].path :
+			 "<builtin configuration>";
 
 	ErrorF ("Parse error on line %d of section %s in file %s\n\t",
-		 configLineNo, configSection, configPath);
+		 configLineNo, configSection, filename);
 	va_start (ap, format);
 	VErrorF (format, ap);
 	va_end (ap);
@@ -902,8 +1070,10 @@ void
 xf86validationError (char *format,...)
 {
 	va_list ap;
+	char *filename = numFiles ? configFiles[curFileIndex].path :
+			 "<builtin configuration>";
 
-	ErrorF ("Data incomplete in file %s\n\t", configPath);
+	ErrorF ("Data incomplete in file %s\n\t", filename);
 	va_start (ap, format);
 	VErrorF (format, ap);
 	va_end (ap);
@@ -1028,3 +1198,33 @@ xf86addComment(char *cur, char *add)
 
 	return (cur);
 }
+
+Bool
+xf86getBoolValue(Bool *val, const char *str)
+{
+	if (!val || !str)
+		return FALSE;
+	if (*str == '\0') {
+		*val = TRUE;
+	} else {
+		if (xf86nameCompare(str, "1") == 0)
+			*val = TRUE;
+		else if (xf86nameCompare(str, "on") == 0)
+			*val = TRUE;
+		else if (xf86nameCompare(str, "true") == 0)
+			*val = TRUE;
+		else if (xf86nameCompare(str, "yes") == 0)
+			*val = TRUE;
+		else if (xf86nameCompare(str, "0") == 0)
+			*val = FALSE;
+		else if (xf86nameCompare(str, "off") == 0)
+			*val = FALSE;
+		else if (xf86nameCompare(str, "false") == 0)
+			*val = FALSE;
+		else if (xf86nameCompare(str, "no") == 0)
+			*val = FALSE;
+		else
+			return FALSE;
+	}
+	return TRUE;
+}
diff --git a/hw/xfree86/parser/write.c b/hw/xfree86/parser/write.c
index 3b77b93..083203c 100644
--- a/hw/xfree86/parser/write.c
+++ b/hw/xfree86/parser/write.c
@@ -117,6 +117,8 @@ doWriteConfigFile (const char *filename, XF86ConfigPtr cptr)
 
 	xf86printInputSection (cf, cptr->conf_input_lst);
 
+	xf86printInputClassSection (cf, cptr->conf_inputclass_lst);
+
 	xf86printVideoAdaptorSection (cf, cptr->conf_videoadaptor_lst);
 
 	xf86printModesSection (cf, cptr->conf_modes_lst);
diff --git a/hw/xfree86/parser/xf86Parser.h b/hw/xfree86/parser/xf86Parser.h
index 6030800..d79544a 100644
--- a/hw/xfree86/parser/xf86Parser.h
+++ b/hw/xfree86/parser/xf86Parser.h
@@ -64,6 +64,7 @@
 #ifndef _xf86Parser_h_
 #define _xf86Parser_h_
 
+#include <X11/Xdefs.h>
 #include "xf86Optrec.h"
 
 #define HAVE_PARSER_DECLS
@@ -330,6 +331,33 @@ typedef struct
 }
 XF86ConfInputrefRec, *XF86ConfInputrefPtr;
 
+typedef struct
+{
+	Bool set;
+	Bool val;
+}
+xf86TriState;
+
+typedef struct
+{
+	GenericListRec list;
+	char *identifier;
+	char *driver;
+	char **match_product;
+	char **match_vendor;
+	char **match_device;
+	char **match_tag;
+	xf86TriState is_keyboard;
+	xf86TriState is_pointer;
+	xf86TriState is_joystick;
+	xf86TriState is_tablet;
+	xf86TriState is_touchpad;
+	xf86TriState is_touchscreen;
+	XF86OptionPtr option_lst;
+	char *comment;
+}
+XF86ConfInputClassRec, *XF86ConfInputClassPtr;
+
 /* Values for adj_where */
 #define CONF_ADJ_OBSOLETE	-1
 #define CONF_ADJ_ABSOLUTE	0
@@ -438,6 +466,7 @@ typedef struct
 	XF86ConfDevicePtr conf_device_lst;
 	XF86ConfScreenPtr conf_screen_lst;
 	XF86ConfInputPtr conf_input_lst;
+	XF86ConfInputClassPtr conf_inputclass_lst;
 	XF86ConfLayoutPtr conf_layout_lst;
 	XF86ConfVendorPtr conf_vendor_lst;
 	XF86ConfDRIPtr conf_dri;
@@ -456,13 +485,16 @@ xf86ConfigSymTabRec, *xf86ConfigSymTabPtr;
 /*
  * prototypes for public functions
  */
-extern _X_EXPORT const char *xf86openConfigFile (const char *, const char *,
-					const char *);
-extern _X_EXPORT void xf86setBuiltinConfig(const char *config[]);
-extern _X_EXPORT XF86ConfigPtr xf86readConfigFile (void);
-extern _X_EXPORT void xf86closeConfigFile (void);
-extern _X_EXPORT void xf86freeConfig (XF86ConfigPtr p);
-extern _X_EXPORT int xf86writeConfigFile (const char *, XF86ConfigPtr);
+extern void xf86initConfigFiles(void);
+extern const char *xf86openConfigFile(const char *path, const char *cmdline,
+				      const char *projroot);
+extern const char *xf86openConfigDirFiles(const char *path, const char *cmdline,
+					  const char *projroot);
+extern void xf86setBuiltinConfig(const char *config[]);
+extern XF86ConfigPtr xf86readConfigFile(void);
+extern void xf86closeConfigFile(void);
+extern void xf86freeConfig(XF86ConfigPtr p);
+extern int xf86writeConfigFile(const char *, XF86ConfigPtr);
 extern _X_EXPORT XF86ConfDevicePtr xf86findDevice(const char *ident, XF86ConfDevicePtr p);
 extern _X_EXPORT XF86ConfLayoutPtr xf86findLayout(const char *name, XF86ConfLayoutPtr list);
 extern _X_EXPORT XF86ConfMonitorPtr xf86findMonitor(const char *ident, XF86ConfMonitorPtr p);
@@ -473,6 +505,7 @@ extern _X_EXPORT XF86ConfInputPtr xf86findInput(const char *ident, XF86ConfInput
 extern _X_EXPORT XF86ConfInputPtr xf86findInputByDriver(const char *driver, XF86ConfInputPtr p);
 extern _X_EXPORT XF86ConfVideoAdaptorPtr xf86findVideoAdaptor(const char *ident,
 						XF86ConfVideoAdaptorPtr p);
+extern int xf86layoutAddInputDevices(XF86ConfigPtr config, XF86ConfLayoutPtr layout);
 
 extern _X_EXPORT GenericListPtr xf86addListItem(GenericListPtr head, GenericListPtr c_new);
 extern _X_EXPORT int xf86itemNotSublist(GenericListPtr list_1, GenericListPtr list_2);
@@ -480,5 +513,6 @@ extern _X_EXPORT int xf86itemNotSublist(GenericListPtr list_1, GenericListPtr li
 extern _X_EXPORT int xf86pathIsAbsolute(const char *path);
 extern _X_EXPORT int xf86pathIsSafe(const char *path);
 extern _X_EXPORT char *xf86addComment(char *cur, char *add);
+extern _X_EXPORT Bool xf86getBoolValue(Bool *val, const char *str);
 
 #endif /* _xf86Parser_h_ */
diff --git a/hw/xfree86/parser/xf86tokens.h b/hw/xfree86/parser/xf86tokens.h
index 4c1d38c..cb60070 100644
--- a/hw/xfree86/parser/xf86tokens.h
+++ b/hw/xfree86/parser/xf86tokens.h
@@ -273,7 +273,19 @@ typedef enum {
 
     /* DRI Tokens */
     GROUP,
-    BUFFERS
+    BUFFERS,
+
+    /* InputClass Tokens */
+    MATCH_PRODUCT,
+    MATCH_VENDOR,
+    MATCH_DEVICE_PATH,
+    MATCH_TAG,
+    MATCH_IS_KEYBOARD,
+    MATCH_IS_POINTER,
+    MATCH_IS_JOYSTICK,
+    MATCH_IS_TABLET,
+    MATCH_IS_TOUCHPAD,
+    MATCH_IS_TOUCHSCREEN
 } ParserTokens;
 
 #endif /* _xf86_tokens_h */
diff --git a/hw/xnest/Init.c b/hw/xnest/Init.c
index 0765f73..2e61979 100644
--- a/hw/xnest/Init.c
+++ b/hw/xnest/Init.c
@@ -112,12 +112,17 @@ InitInput(int argc, char *argv[])
 /*
  * DDX - specific abort routine.  Called by AbortServer().
  */
-void AbortDDX(void)
+void SigAbortDDX(int signo)
 {
   xnestDoFullGeneration = True;
   xnestCloseDisplay();
 }
 
+void AbortDDX(void)
+{
+    SigAbortDDX(0);
+}
+
 /* Called by GiveUp(). */
 void ddxGiveUp(void)
 {
diff --git a/hw/xquartz/darwin.c b/hw/xquartz/darwin.c
index 8b6ce62..7b81493 100644
--- a/hw/xquartz/darwin.c
+++ b/hw/xquartz/darwin.c
@@ -804,12 +804,12 @@ void ddxGiveUp( void )
 
 
 /*
- * AbortDDX --
+ * [Sig]AbortDDX --
  *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
  *      made to restore all original setting of the displays. Also all devices
  *      are closed.
  */
-void AbortDDX( void )
+void SigAbortDDX( void )
 {
     ErrorF( "   AbortDDX\n" );
     /*
@@ -819,6 +819,11 @@ void AbortDDX( void )
     ddxGiveUp();
 }
 
+void AbortDDX( void )
+{
+    SigAbortDDX(0);
+}
+
 #include "mivalidate.h" // for union _Validate used by windowstr.h
 #include "windowstr.h"  // for struct _Window
 #include "scrnintstr.h" // for struct _Screen
diff --git a/hw/xquartz/darwinXinput.c b/hw/xquartz/darwinXinput.c
index 8af9fc7..7500e21 100644
--- a/hw/xquartz/darwinXinput.c
+++ b/hw/xquartz/darwinXinput.c
@@ -236,6 +236,14 @@ NewInputDeviceRequest(InputOption *options, DeviceIntPtr *pdev)
   return BadValue;
 }
 
+int
+NewInputDeviceRequest18(InputOption *options, InputAttributes *attrs,
+                      DeviceIntPtr *pdev)
+{
+  DEBUG_LOG("NewInputDeviceRequest(%p, %p)\n", options, pdev);
+  return BadValue;
+}
+
 /****************************************************************************
  *
  * Caller: configRemoveDevice (and others)
diff --git a/hw/xwin/InitOutput.c b/hw/xwin/InitOutput.c
index 9aff336..17e9c3d 100644
--- a/hw/xwin/InitOutput.c
+++ b/hw/xwin/InitOutput.c
@@ -283,7 +283,7 @@ ddxGiveUp (void)
 
 /* See Porting Layer Definition - p. 57 */
 void
-AbortDDX (void)
+SigAbortDDX (int signo)
 {
 #if CYGDEBUG
   winDebug ("AbortDDX\n");
@@ -291,6 +291,12 @@ AbortDDX (void)
   ddxGiveUp ();
 }
 
+void
+AbortDDX (void)
+{
+    SigAbortDDX(0);
+}
+
 #ifdef __CYGWIN__
 /* hasmntopt is currently not implemented for cygwin */
 static const char *winCheckMntOpt(const struct mntent *mnt, const char *opt)
@@ -851,6 +857,9 @@ winUseMsg (void)
   ErrorF ("-config\n"
           "\tSpecify a configuration file.\n");
 
+  ErrorF ("-configdir\n"
+          "\tSpecify a configuration directory.\n");
+
   ErrorF ("-keyboard\n"
 	  "\tSpecify a keyboard device from the configuration file.\n");
 #endif
diff --git a/hw/xwin/winconfig.c b/hw/xwin/winconfig.c
index 3e1908c..259b3d2 100644
--- a/hw/xwin/winconfig.c
+++ b/hw/xwin/winconfig.c
@@ -50,6 +50,13 @@
                     "%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
                     "%P/lib/X11/%X"
 #endif
+#ifndef CONFIGDIRPATH
+#define CONFIGDIRPATH  "/etc/X11/%X-%M," "/etc/X11/%X," "/etc/%X," \
+                       "%P/etc/X11/%X.%H," "%P/etc/X11/%X-%M," \
+                       "%P/etc/X11/%X," \
+                       "%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
+                       "%P/lib/X11/%X"
+#endif
 
 XF86ConfigPtr g_xf86configptr = NULL;
 #endif
@@ -57,6 +64,7 @@ XF86ConfigPtr g_xf86configptr = NULL;
 WinCmdlineRec g_cmdline = {
 #ifdef XWIN_XF86CONFIG
   NULL,				/* configFile */
+  NULL,				/* configDir */
 #endif
   NULL,				/* fontPath */
 #ifdef XWIN_XF86CONFIG
@@ -109,20 +117,28 @@ Bool
 winReadConfigfile ()
 {
   Bool		retval = TRUE;
-  const char	*filename;
-  MessageType	from = X_DEFAULT;
+  const char	*filename, *dirname;
+  MessageType	filefrom = X_DEFAULT;
+  MessageType	dirfrom = X_DEFAULT;
   char		*xf86ConfigFile = NULL;
+  char		*xf86ConfigDir = NULL;
 
   if (g_cmdline.configFile)
     {
-      from = X_CMDLINE;
+      filefrom = X_CMDLINE;
       xf86ConfigFile = g_cmdline.configFile;
     }
+  if (g_cmdline.configDir)
+    {
+      dirfrom = X_CMDLINE;
+      xf86ConfigDir = g_cmdline.configDir;
+    }
 
   /* Parse config file into data structure */
-
+  xf86initConfigFiles();
+  dirname = xf86openConfigDirFiles (CONFIGDIRPATH, xf86ConfigDir, PROJECTROOT);
   filename = xf86openConfigFile (CONFIGPATH, xf86ConfigFile, PROJECTROOT);
-    
+
   /* Hack for backward compatibility */
   if (!filename && from == X_DEFAULT)
     filename = xf86openConfigFile (CONFIGPATH, "XF86Config", PROJECTROOT);
@@ -137,6 +153,20 @@ winReadConfigfile ()
       if (xf86ConfigFile)
 	ErrorF (": \"%s\"", xf86ConfigFile);
       ErrorF ("\n");
+    }
+  if (dirname)
+    {
+      winMsg (from, "Using config directory: \"%s\"\n", dirname);
+    }
+  else
+    {
+      winMsg (X_ERROR, "Unable to locate/open config directory");
+      if (xf86ConfigDir)
+	ErrorF (": \"%s\"", xf86ConfigDir);
+      ErrorF ("\n");
+    }
+  if (!filename && !dirname)
+    {
       return FALSE;
     }
   if ((g_xf86configptr = xf86readConfigFile ()) == NULL)
diff --git a/hw/xwin/winconfig.h b/hw/xwin/winconfig.h
index 63d6211..058884a 100644
--- a/hw/xwin/winconfig.h
+++ b/hw/xwin/winconfig.h
@@ -188,6 +188,7 @@ typedef struct
   /* Files */
 #ifdef XWIN_XF86CONFIG
   char *configFile;
+  char *configDir;
 #endif
   char *fontPath;
   /* input devices - keyboard */
diff --git a/hw/xwin/winprocarg.c b/hw/xwin/winprocarg.c
index 56af643..7c0dcae 100755
--- a/hw/xwin/winprocarg.c
+++ b/hw/xwin/winprocarg.c
@@ -1318,6 +1318,24 @@ ddxProcessArgument (int argc, char *argv[], int i)
     }
 
   /*
+   * Look for the '-configdir' argument
+   */
+  if (IS_OPTION ("-configdir"))
+    {
+      CHECK_ARGS (1);
+#ifdef XWIN_XF86CONFIG
+      g_cmdline.configDir = argv[++i];
+#else
+      winMessageBoxF ("The %s option is not supported in this "
+		      "release.\n"
+		      "Ignoring this option and continuing.\n",
+		      MB_ICONINFORMATION,
+		      argv[i]);
+#endif
+      return 2;
+    }
+
+  /*
    * Look for the '-keyboard' argument
    */
   if (IS_OPTION ("-keyboard"))
diff --git a/include/dix-config.h.in b/include/dix-config.h.in
index 6e450b6..944a006 100644
--- a/include/dix-config.h.in
+++ b/include/dix-config.h.in
@@ -163,6 +163,12 @@
 /* Define to use libmd SHA1 functions instead of OpenSSL libcrypto */
 #undef HAVE_SHA1_IN_LIBMD
 
+/* Define to use libgcrypt SHA1 functions instead of OpenSSL libcrypto */
+#undef HAVE_SHA1_IN_LIBGCRYPT
+
+/* Define to use libnettle SHA1 functions instead of OpenSSL libcrypto */
+#undef HAVE_SHA1_IN_LIBNETTLE
+
 /* Define to 1 if you have the `shmctl64' function. */
 #undef HAVE_SHMCTL64
 
@@ -219,6 +225,9 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
+/* Define to 1 if you have the <fnmatch.h> header file. */
+#undef HAVE_FNMATCH_H
+
 /* Have /dev/urandom */
 #undef HAVE_URANDOM
 
@@ -384,6 +393,9 @@
 /* Support D-Bus */
 #undef HAVE_DBUS
 
+/* Use libudev for input hotplug */
+#undef CONFIG_UDEV
+
 /* Use D-Bus for input hotplug */
 #undef CONFIG_NEED_DBUS
 
diff --git a/include/do-not-use-config.h.in b/include/do-not-use-config.h.in
index 65b54b0..79049dd 100644
--- a/include/do-not-use-config.h.in
+++ b/include/do-not-use-config.h.in
@@ -36,6 +36,9 @@
 /* Use D-Bus for input hotplug */
 #undef CONFIG_NEED_DBUS
 
+/* Use libudev for input hotplug */
+#undef CONFIG_UDEV
+
 /* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
    systems. This function is required for `alloca.c' support on those systems.
    */
@@ -95,6 +98,9 @@
 /* Default DRI driver path */
 #undef DRI_DRIVER_PATH
 
+/* Extra module search path, searched before the default one */
+#undef EXTRA_MODULE_PATH
+
 /* Build GLX extension */
 #undef GLXEXT
 
@@ -190,6 +196,9 @@
 /* Define to 1 if you have the `ffs' function. */
 #undef HAVE_FFS
 
+/* Define to 1 if you have the <fnmatch.h> header file. */
+#undef HAVE_FNMATCH_H
+
 /* Define to 1 if you have the `geteuid' function. */
 #undef HAVE_GETEUID
 
@@ -274,9 +283,15 @@
 /* Define to 1 if you have the <SDL/SDL.h> header file. */
 #undef HAVE_SDL_SDL_H
 
-/* Use libmd SHA1 functions instead of OpenSSL libcrypto */
+/* Use libgcrypt SHA1 functions */
+#undef HAVE_SHA1_IN_LIBGCRYPT
+
+/* Use libmd SHA1 functions */
 #undef HAVE_SHA1_IN_LIBMD
 
+/* Use libnettle SHA1 functions */
+#undef HAVE_SHA1_IN_LIBNETTLE
+
 /* Define to 1 if you have the `shmctl64' function. */
 #undef HAVE_SHMCTL64
 
@@ -439,6 +454,9 @@
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
@@ -730,6 +748,9 @@
 /* Vendor web address for support */
 #undef __VENDORDWEBSUPPORT__
 
+/* Name of configuration directory */
+#undef __XCONFIGDIR__
+
 /* Name of configuration file */
 #undef __XCONFIGFILE__
 
diff --git a/include/exevents.h b/include/exevents.h
index 39e1c70..20785f2 100644
--- a/include/exevents.h
+++ b/include/exevents.h
@@ -48,7 +48,14 @@ extern _X_EXPORT void InitValuatorAxisStruct(
 	int                    /* maxval */,
 	int                    /* resolution */,
 	int                    /* min_res */,
-	int                    /* max_res */);
+	int                    /* max_res */
+);
+
+extern _X_EXPORT void SetValuatorAxisNoIntegration(
+	DeviceIntPtr           /* dev */,
+	int                    /* axnum */,
+	Bool                   /* no_integration */
+);
 
 /* Input device properties */
 extern _X_EXPORT void XIDeleteAllDeviceProperties(
diff --git a/include/input.h b/include/input.h
index afcc006..7c00e5d 100644
--- a/include/input.h
+++ b/include/input.h
@@ -52,6 +52,7 @@ SOFTWARE.
 #include "screenint.h"
 #include <X11/Xmd.h>
 #include <X11/Xproto.h>
+#include <stdint.h>
 #include "window.h"     /* for WindowPtr */
 #include "xkbrules.h"
 #include "events.h"
@@ -210,6 +211,21 @@ typedef struct _InputOption {
     struct _InputOption *next;
 } InputOption;
 
+typedef struct _InputAttributes {
+    char                *product;
+    char                *vendor;
+    char                *device;
+    char                **tags; /* null-terminated */
+    uint32_t            flags;
+} InputAttributes;
+
+#define ATTR_KEYBOARD (1<<0)
+#define ATTR_POINTER (1<<1)
+#define ATTR_JOYSTICK (1<<2)
+#define ATTR_TABLET (1<<3)
+#define ATTR_TOUCHPAD (1<<4)
+#define ATTR_TOUCHSCREEN (1<<5)
+
 /* Key has been run through all input processing and events sent to clients. */
 #define KEY_PROCESSED 1
 /* Key has not been fully processed, no events have been sent. */
@@ -515,6 +531,10 @@ void FixUpEventFromWindow(DeviceIntPtr pDev,
 extern _X_EXPORT int NewInputDeviceRequest(
     InputOption *options,
     DeviceIntPtr *dev);
+extern int NewInputDeviceRequest18(
+    InputOption *options,
+    InputAttributes *attrs,
+    DeviceIntPtr *dev);
 extern  _X_EXPORT void DeleteInputDeviceRequest(
     DeviceIntPtr dev);
 
diff --git a/include/inputstr.h b/include/inputstr.h
index 15184d0..3297926 100644
--- a/include/inputstr.h
+++ b/include/inputstr.h
@@ -216,6 +216,7 @@ typedef struct _AxisInfo {
     int		min_value;
     int		max_value;
     Atom	label;
+    Bool	no_integration;
 } AxisInfo, *AxisInfoPtr;
 
 typedef struct _ValuatorAccelerationRec {
diff --git a/include/misc.h b/include/misc.h
index 877c682..62d813e 100644
--- a/include/misc.h
+++ b/include/misc.h
@@ -210,6 +210,9 @@ pad_to_int32(const int bytes) {
     return (((bytes) + 3) & ~3);
 }
 
+extern char**
+xstrtokenize(const char *str, const char* separators);
+
 /* some macros to help swap requests, replies, and events */
 
 #define LengthRestB(stuff) \
diff --git a/include/opaque.h b/include/opaque.h
index b3c7c70..fcc8c95 100644
--- a/include/opaque.h
+++ b/include/opaque.h
@@ -71,6 +71,7 @@ extern _X_EXPORT Bool defeatAccessControl;
 extern _X_EXPORT long maxBigRequestSize;
 extern _X_EXPORT Bool party_like_its_1989;
 extern _X_EXPORT Bool whiteRoot;
+extern _X_EXPORT Bool bgNoneRoot;
 
 extern _X_EXPORT Bool CoreDump;
 
diff --git a/include/os.h b/include/os.h
index 2f6b0c0..d58be5e 100644
--- a/include/os.h
+++ b/include/os.h
@@ -434,7 +434,9 @@ typedef struct {
 /* stuff for FlushCallback */
 extern _X_EXPORT CallbackListPtr FlushCallback;
 
+extern _X_EXPORT void SigAbortDDX(int signo);
 extern _X_EXPORT void AbortDDX(void);
+extern _X_EXPORT void ddxSigGiveUp(int signo);
 extern _X_EXPORT void ddxGiveUp(void);
 extern _X_EXPORT int TimeSinceLastInputEvent(void);
 
diff --git a/include/xorg-config.h.in b/include/xorg-config.h.in
index 9fe7cde..cf463ab 100644
--- a/include/xorg-config.h.in
+++ b/include/xorg-config.h.in
@@ -36,9 +36,15 @@
 /* Path to configuration file. */
 #undef __XCONFIGFILE__
 
+/* Name of configuration directory. */
+#undef __XCONFIGDIR__
+
 /* Path to loadable modules. */
 #undef DEFAULT_MODULE_PATH
 
+/* Path to extra loadable modules. */
+#undef EXTRA_MODULE_PATH
+
 /* Path to installed libraries. */
 #undef DEFAULT_LIBRARY_PATH
 
diff --git a/ltmain.sh b/ltmain.sh
index a72f2fd..7ed280b 100755
--- a/ltmain.sh
+++ b/ltmain.sh
@@ -65,7 +65,7 @@
 #       compiler:		$LTCC
 #       compiler flags:		$LTCFLAGS
 #       linker:		$LD (gnu? $with_gnu_ld)
-#       $progname:		(GNU libtool) 2.2.6b
+#       $progname:		(GNU libtool) 2.2.6b Debian-2.2.6b-2ubuntu1
 #       automake:		$automake_version
 #       autoconf:		$autoconf_version
 #
@@ -73,7 +73,7 @@
 
 PROGRAM=ltmain.sh
 PACKAGE=libtool
-VERSION=2.2.6b
+VERSION="2.2.6b Debian-2.2.6b-2ubuntu1"
 TIMESTAMP=""
 package_revision=1.3017
 
@@ -5033,7 +5033,10 @@ func_mode_link ()
 	case $pass in
 	dlopen) libs="$dlfiles" ;;
 	dlpreopen) libs="$dlprefiles" ;;
-	link) libs="$deplibs %DEPLIBS% $dependency_libs" ;;
+	link)
+	  libs="$deplibs %DEPLIBS%"
+	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
+	  ;;
 	esac
       fi
       if test "$linkmode,$pass" = "lib,dlpreopen"; then
@@ -5344,19 +5347,19 @@ func_mode_link ()
 	    # It is a libtool convenience library, so add in its objects.
 	    convenience="$convenience $ladir/$objdir/$old_library"
 	    old_convenience="$old_convenience $ladir/$objdir/$old_library"
+	    tmp_libs=
+	    for deplib in $dependency_libs; do
+	      deplibs="$deplib $deplibs"
+	      if $opt_duplicate_deps ; then
+		case "$tmp_libs " in
+		*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+		esac
+	      fi
+	      tmp_libs="$tmp_libs $deplib"
+	    done
 	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
 	    func_fatal_error "\`$lib' is not a convenience library"
 	  fi
-	  tmp_libs=
-	  for deplib in $dependency_libs; do
-	    deplibs="$deplib $deplibs"
-	    if $opt_duplicate_deps ; then
-	      case "$tmp_libs " in
-	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
-	      esac
-	    fi
-	    tmp_libs="$tmp_libs $deplib"
-	  done
 	  continue
 	fi # $pass = conv
 
@@ -5893,6 +5896,7 @@ func_mode_link ()
 	  if test "$link_all_deplibs" != no; then
 	    # Add the search paths of all dependency libraries
 	    for deplib in $dependency_libs; do
+	      path=
 	      case $deplib in
 	      -L*) path="$deplib" ;;
 	      *.la)
@@ -6206,6 +6210,9 @@ func_mode_link ()
 	    revision="$number_minor"
 	    lt_irix_increment=no
 	    ;;
+	  *)
+	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    ;;
 	  esac
 	  ;;
 	no)
diff --git a/mi/miarc.c b/mi/miarc.c
index a3e2580..54fd743 100644
--- a/mi/miarc.c
+++ b/mi/miarc.c
@@ -1524,7 +1524,7 @@ miRoundCap(
 
 # define Dsin(d)	((d) == 0.0 ? 0.0 : ((d) == 90.0 ? 1.0 : sin(d*M_PI/180.0)))
 # define Dcos(d)	((d) == 0.0 ? 1.0 : ((d) == 90.0 ? 0.0 : cos(d*M_PI/180.0)))
-# define mod(a,b)	((a) >= 0 ? (a) % (b) : (b) - (-a) % (b))
+# define mod(a,b)	((a) >= 0 ? (a) % (b) : (b) - (-(a)) % (b))
 
 static double
 miDcos (double a)
diff --git a/mi/mipointer.c b/mi/mipointer.c
index e1f63be..318e9fc 100644
--- a/mi/mipointer.c
+++ b/mi/mipointer.c
@@ -139,6 +139,10 @@ miPointerCloseScreen (int index, ScreenPtr pScreen)
         if (DevHasCursor(pDev))
         {
             pPointer = MIPOINTER(pDev);
+            if (pPointer == NULL) {
+                ErrorF("miPointerCloseScreen: Invalid input device pointer\n");
+                return FALSE;
+            }
 
             if (pScreen == pPointer->pScreen)
                 pPointer->pScreen = 0;
@@ -191,6 +195,10 @@ miPointerDisplayCursor (DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
             return FALSE;
 
     pPointer = MIPOINTER(pDev);
+    if (pPointer == NULL) {
+        ErrorF("miPointerDisplayCursor: Invalid input device pointer\n");
+        return FALSE;
+    }
 
     pPointer->pCursor = pCursor;
     pPointer->pScreen = pScreen;
@@ -204,6 +212,10 @@ miPointerConstrainCursor (DeviceIntPtr pDev, ScreenPtr pScreen, BoxPtr pBox)
     miPointerPtr pPointer;
 
     pPointer = MIPOINTER(pDev);
+    if (pPointer == NULL) {
+        ErrorF("miPointerConstrainCursor: Invalid input device pointer\n");
+        return FALSE;
+    }
 
     pPointer->limits = *pBox;
     pPointer->confined = PointerConfinedToScreen(pDev);
@@ -306,6 +318,15 @@ miPointerWarpCursor (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
     SetupScreen (pScreen);
     pPointer = MIPOINTER(pDev);
 
+    /* Null pointer causes crash on keyrepeat with Xinerama LP: (#324465) */
+    if (pPointer == NULL)
+        return;
+
+    if (pPointer == NULL) {
+        ErrorF("miPointerWarpCursor: Invalid input device pointer\n");
+        return;
+    }
+
     if (pPointer->pScreen != pScreen)
     {
 	(*pScreenPriv->screenFuncs->NewEventScreen) (pDev, pScreen, TRUE);
@@ -366,6 +387,10 @@ miPointerUpdateSprite (DeviceIntPtr pDev)
         return;
 
     pPointer = MIPOINTER(pDev);
+    if (pPointer == NULL) {
+        ErrorF("miPointerUpdateSprite: Invalid input device pointer\n");
+        return;
+    }
 
     if (!pPointer)
         return;
@@ -436,13 +461,17 @@ miPointerSetScreen(DeviceIntPtr pDev, int screen_no, int x, int y)
 	ScreenPtr pScreen;
         miPointerPtr pPointer;
 
-        pPointer = MIPOINTER(pDev);
-
 	pScreen = screenInfo.screens[screen_no];
 	pScreenPriv = GetScreenPrivate (pScreen);
 	(*pScreenPriv->screenFuncs->NewEventScreen) (pDev, pScreen, FALSE);
 	NewCurrentScreen (pDev, pScreen, x, y);
 
+        pPointer = MIPOINTER(pDev);
+        if (pPointer == NULL) {
+            ErrorF("miPointerSetScreen: Invalid input device pointer\n");
+            return;
+        }
+
         pPointer->limits.x2 = pScreen->width;
         pPointer->limits.y2 = pScreen->height;
 }
@@ -469,6 +498,10 @@ miPointerMoved (DeviceIntPtr pDev, ScreenPtr pScreen,
     SetupScreen(pScreen);
 
     pPointer = MIPOINTER(pDev);
+    if (pPointer == NULL) {
+        ErrorF("miPointerMoved: Invalid input device pointer\n");
+        return;
+    }
 
     /* Hack: We mustn't call into ->MoveCursor for anything but the
      * VCP, as this may cause a non-HW rendered cursor to be rendered during
@@ -498,6 +531,11 @@ miPointerSetPosition(DeviceIntPtr pDev, int *x, int *y)
     miPointerPtr        pPointer; 
 
     pPointer = MIPOINTER(pDev);
+    if (pPointer == NULL) {
+        ErrorF("miPointerSetPosition: Invalid input device pointer\n");
+        return;
+    }
+
     pScreen = pPointer->pScreen;
     if (!pScreen)
 	return;	    /* called before ready */
diff --git a/miext/cw/cw_render.c b/miext/cw/cw_render.c
index 6e0c727..fe8cba7 100644
--- a/miext/cw/cw_render.c
+++ b/miext/cw/cw_render.c
@@ -125,10 +125,15 @@ cwGetBackingPicture (PicturePtr pPicture, int *x_off, int *y_off)
 	WindowPtr   pWindow = (WindowPtr) pDrawable;
 	PixmapPtr   pPixmap = getCwPixmap (pWindow);
 
-	*x_off = pDrawable->x - pPixmap->screen_x;
-	*y_off = pDrawable->y - pPixmap->screen_y;
-
-	return pPicturePrivate->pBackingPicture;
+        if (pDrawable && pPixmap) {
+            *x_off = pDrawable->x - pPixmap->screen_x;
+            *y_off = pDrawable->y - pPixmap->screen_y;
+
+            return pPicturePrivate->pBackingPicture;
+        } else {
+            *x_off = *y_off = 0;
+            return pPicture;
+        }
     }
     else
     {
diff --git a/os/log.c b/os/log.c
index 8108890..3167bd4 100644
--- a/os/log.c
+++ b/os/log.c
@@ -389,11 +389,12 @@ LogMessage(MessageType type, const char *format, ...)
 }
 
 #ifdef __GNUC__
+void SigAbortServer(int signo) __attribute__((noreturn));
 void AbortServer(void) __attribute__((noreturn));
 #endif
 
 void
-AbortServer(void)
+SigAbortServer(int signo)
 {
 #ifdef XF86BIGFONT
     XF86BigfontCleanup();
@@ -401,11 +402,21 @@ AbortServer(void)
     CloseWellKnownConnections();
     OsCleanup(TRUE);
     CloseDownDevices();
-    AbortDDX();
+    SigAbortDDX(signo);
     fflush(stderr);
-    if (CoreDump)
-	abort();
-    exit (1);
+    if (CoreDump) {
+        if (signo != 0)
+            raise(signo);
+        else
+            abort();
+    } else
+	exit (1);
+}
+
+void
+AbortServer(void)
+{
+    SigAbortServer(0);
 }
 
 #define AUDIT_PREFIX "AUDIT: %s: %ld: "
@@ -508,6 +519,27 @@ VAuditF(const char *f, va_list args)
 }
 
 void
+FatalSignal(int signo)
+{
+    static Bool beenhere = FALSE;
+
+    if (beenhere)
+	ErrorF("\nFatalSignal re-entered, aborting\n");
+    else
+	ErrorF("\nCaught signal %d (%s). Server aborting\n",
+               signo, strsignal(signo));
+
+    if (!beenhere)
+	OsVendorFatalError();
+    if (!beenhere) {
+	beenhere = TRUE;
+	SigAbortServer(signo);
+    } else
+	abort();
+    /*NOTREACHED*/
+}
+
+void
 FatalError(const char *f, ...)
 {
     va_list args;
diff --git a/os/osinit.c b/os/osinit.c
index e8fcd45..7541de1 100644
--- a/os/osinit.c
+++ b/os/osinit.c
@@ -148,13 +148,13 @@ OsSigHandler(int signo)
           case SIGBUS:
           case SIGILL:
           case SIGFPE:
+	      signal(signo,SIG_DFL);
 	      ErrorF("%s at address %p\n", strsignal(signo), sip->si_addr);
       }
   }
 #endif
 
-  FatalError("Caught signal %d (%s). Server aborting\n",
-	     signo, strsignal(signo));
+  FatalSignal(signo);
 }
 
 void
diff --git a/os/utils.c b/os/utils.c
index d7c8388..3de0906 100644
--- a/os/utils.c
+++ b/os/utils.c
@@ -513,6 +513,7 @@ void UseMsg(void)
 #endif
     ErrorF("-nolisten string       don't listen on protocol\n");
     ErrorF("-noreset               don't reset after last client exists\n");
+    ErrorF("-nr                    create root window with no background\n");
     ErrorF("-reset                 reset after last client exists\n");
     ErrorF("-p #                   screen-saver pattern duration (minutes)\n");
     ErrorF("-pn                    accept failure to listen on all ports\n");
@@ -856,6 +857,8 @@ ProcessCommandLine(int argc, char *argv[])
 	    defaultBackingStore = WhenMapped;
         else if ( strcmp( argv[i], "-wr") == 0)
             whiteRoot = TRUE;
+        else if ( strcmp( argv[i], "-nr") == 0)
+            bgNoneRoot = TRUE;
         else if ( strcmp( argv[i], "-maxbigreqsize") == 0) {
              if(++i < argc) {
                  long reqSizeArg = atol(argv[i]);
@@ -1870,6 +1873,46 @@ CheckUserAuthorization(void)
 #endif
 }
 
+/*
+ * Tokenize a string into a NULL terminated array of strings. Always returns
+ * an allocated array unless an error occurs.
+ */
+char**
+xstrtokenize(const char *str, const char *separators)
+{
+    char **list, **nlist;
+    char *tok, *tmp;
+    unsigned num = 0, n;
+
+    if (!str)
+        return NULL;
+    list = calloc(1, sizeof(*list));
+    if (!list)
+        return NULL;
+    tmp = strdup(str);
+    if (!tmp)
+        goto error;
+    for (tok = strtok(tmp, separators); tok; tok = strtok(NULL, separators)) {
+        nlist = realloc(list, (num + 2) * sizeof(*list));
+        if (!nlist)
+            goto error;
+        list = nlist;
+        list[num] = strdup(tok);
+        if (!list[num])
+            goto error;
+        list[++num] = NULL;
+    }
+    free(tmp);
+    return list;
+
+error:
+    free(tmp);
+    for (n = 0; n < num; n++)
+        free(list[n]);
+    free(list);
+    return NULL;
+}
+
 #ifdef __SCO__
 #include <fcntl.h>
 
diff --git a/randr/randr.c b/randr/randr.c
index 5944564..ad33acc 100644
--- a/randr/randr.c
+++ b/randr/randr.c
@@ -234,7 +234,7 @@ Bool RRScreenInit(ScreenPtr pScreen)
     /*
      * Calling function best set these function vectors
      */
-    pScrPriv->rrGetInfo = 0;
+    pScrPriv->rrGetInfo = NULL;
     pScrPriv->maxWidth = pScrPriv->minWidth = pScreen->width;
     pScrPriv->maxHeight = pScrPriv->minHeight = pScreen->height;
     
diff --git a/render/glyph.c b/render/glyph.c
index 7fcdfd9..bdedc78 100644
--- a/render/glyph.c
+++ b/render/glyph.c
@@ -28,6 +28,10 @@
 
 #ifdef HAVE_SHA1_IN_LIBMD /* Use libmd for SHA1 */
 # include <sha1.h>
+#elif defined(HAVE_SHA1_IN_LIBGCRYPT)
+# include <gcrypt.h>
+#elif defined(HAVE_SHA1_IN_LIBNETTLE)
+# include <nettle/sha.h>
 #else /* Use OpenSSL's libcrypto */
 # include <stddef.h>  /* buggy openssl/sha.h wants size_t */
 # include <openssl/sha.h>
@@ -205,6 +209,33 @@ HashGlyph (xGlyphInfo    *gi,
     SHA1Update (&ctx, gi, sizeof (xGlyphInfo));
     SHA1Update (&ctx, bits, size);
     SHA1Final (sha1, &ctx);
+#elif defined(HAVE_SHA1_IN_LIBGCRYPT) /* Use libgcrypt for SHA1 */
+    static int init;
+    gcry_md_hd_t h;
+    gcry_error_t err;
+
+    if (!init) {
+	if (!gcry_check_version(NULL))
+	    return BadAlloc;
+	gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
+	gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
+	init = 1;
+    }
+
+    err = gcry_md_open(&h, GCRY_MD_SHA1, 0);
+    if (err)
+	return BadAlloc;
+    gcry_md_write(h, gi, sizeof (xGlyphInfo));
+    gcry_md_write(h, bits, size);
+    memcpy(sha1, gcry_md_read(h, GCRY_MD_SHA1), 20);
+    gcry_md_close(h);
+#elif HAVE_SHA1_IN_LIBNETTLE
+    struct sha1_ctx ctx;
+
+    sha1_init(&ctx);
+    sha1_update(&ctx, sizeof (xGlyphInfo), gi);
+    sha1_update(&ctx, size, bits);
+    sha1_digest(&ctx, 20, sha1);
 #else /* Use OpenSSL's libcrypto */
     SHA_CTX ctx;
     int success;
@@ -235,6 +266,9 @@ FindGlyphByHash (unsigned char sha1[20], int format)
     GlyphRefPtr gr;
     CARD32 signature = *(CARD32 *) sha1;
 
+    if (!globalGlyphs[format].hashSet)
+	return NULL;
+
     gr = FindGlyphRef (&globalGlyphs[format],
 		       signature, TRUE, sha1);
 
diff --git a/xkb/README.compiled b/xkb/README.compiled
index 71caa2f..a4a2ae0 100644
--- a/xkb/README.compiled
+++ b/xkb/README.compiled
@@ -4,10 +4,10 @@ current keymap and/or any scratch keymaps used by clients.  The X server
 or some other tool might destroy or replace the files in this directory,
 so it is not a safe place to store compiled keymaps for long periods of
 time.  The default keymap for any server is usually stored in:
-     X<num>-default.xkm
-where <num> is the display number of the server in question, which makes
-it possible for several servers *on the same host* to share the same 
-directory.
+     server-<SHA1>.xkm
+
+where <SHA1> is the SHA1 hash of keymap source, so that compiled
+keymap of different keymap sources are stored in different files.
 
 Unless the X server is modified, sharing this directory between servers on
 different hosts could cause problems.
diff --git a/xkb/ddxLoad.c b/xkb/ddxLoad.c
index ba8d50b..3901910 100644
--- a/xkb/ddxLoad.c
+++ b/xkb/ddxLoad.c
@@ -32,6 +32,12 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #include <xkb-config.h>
 #endif
 
+#ifdef HAVE_SHA1_IN_LIBGCRYPT /* Use libgcrypt for SHA1 */
+# include <gcrypt.h>
+#else /* Use OpenSSL's libcrypto */
+#warning "xkbcomp caching support disabled"
+#endif
+
 #include <stdio.h>
 #include <ctype.h>
 #include <X11/X.h>
@@ -45,24 +51,13 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #define	XKBSRV_NEED_FILE_FUNCS
 #include <xkbsrv.h>
 #include <X11/extensions/XI.h>
+#include <errno.h>
 #include "xkb.h"
 
 #if defined(CSRG_BASED) || defined(linux) || defined(__GNU__)
 #include <paths.h>
 #endif
 
-	/*
-	 * If XKM_OUTPUT_DIR specifies a path without a leading slash, it is
-	 * relative to the top-level XKB configuration directory.
-	 * Making the server write to a subdirectory of that directory
-	 * requires some work in the general case (install procedure
-	 * has to create links to /var or somesuch on many machines),
-	 * so we just compile into /usr/tmp for now.
-	 */
-#ifndef XKM_OUTPUT_DIR
-#define	XKM_OUTPUT_DIR	"compiled/"
-#endif
-
 #define	PRE_ERROR_MSG "\"The XKEYBOARD keymap compiler (xkbcomp) reports:\""
 #define	ERROR_PREFIX	"\"> \""
 #define	POST_ERROR_MSG1 "\"Errors from xkbcomp are not fatal to the X server\""
@@ -176,6 +171,47 @@ OutputDirectory(
     }
 }
 
+#ifndef SHA_DIGEST_LENGTH
+#define SHA_DIGEST_LENGTH 20
+#endif
+
+static Bool
+Sha1Asc(char sha1Asc[SHA_DIGEST_LENGTH*2+1], const char * input)
+{
+    int i;
+    unsigned char sha1[SHA_DIGEST_LENGTH];
+
+#ifdef HAVE_SHA1_IN_LIBGCRYPT /* Use libgcrypt for SHA1 */
+    static int init;
+    gcry_md_hd_t h;
+    gcry_error_t err;
+
+    if (!init) {
+	if (!gcry_check_version(NULL))
+	    return BadAlloc;
+	gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
+	gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
+	init = 1;
+    }
+
+    err = gcry_md_open(&h, GCRY_MD_SHA1, 0);
+    if (err)
+	return BadAlloc;
+    gcry_md_write(h, input, strlen(input));
+    memcpy(sha1, gcry_md_read(h, GCRY_MD_SHA1), 20);
+    gcry_md_close(h);
+#endif
+
+    /* convert sha1 to sha1_asc */
+    for(i=0; i<SHA_DIGEST_LENGTH; ++i) {
+        sprintf(sha1Asc+i*2, "%02X", sha1[i]);
+    }
+
+    return Success;
+}
+
+/* call xkbcomp and compile XKB keymap, return xkm file name in
+   nameRtrn */
 static Bool
 XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
 				XkbComponentNamesPtr	names,
@@ -185,7 +221,11 @@ XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
 				int			nameRtrnLen)
 {
     FILE *	out;
-    char	*buf = NULL, keymap[PATH_MAX], xkm_output_dir[PATH_MAX];
+    char *	buf = NULL, xkmfile[PATH_MAX], xkm_output_dir[PATH_MAX];
+    char *	tmpXkmFile = NULL;
+    char *	canonicalXkmFileName = NULL;
+    char	sha1Asc[SHA_DIGEST_LENGTH*2+1], xkbKeyMapBuf[100*1024];
+    int	ret, result;
 
     const char	*emptystring = "";
     const char	*xkbbasedirflag = emptystring;
@@ -196,14 +236,67 @@ XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
     /* WIN32 has no popen. The input must be stored in a file which is
        used as input for xkbcomp. xkbcomp does not read from stdin. */
     char tmpname[PATH_MAX];
-    const char *xkmfile = tmpname;
+    const char *xkbfile = tmpname;
 #else
-    const char *xkmfile = "-";
+    const char *xkbfile = "-";
 #endif
 
-    snprintf(keymap, sizeof(keymap), "server-%s", display);
+    /* Write keymap source (xkbfile) to memory buffer `xkbKeyMapBuf',
+       of which SHA1 is generated and used as result xkm file name  */
+    memset(xkbKeyMapBuf, 0, sizeof(xkbKeyMapBuf));
+    out = fmemopen(xkbKeyMapBuf, sizeof(xkbKeyMapBuf), "w");
+    if (NULL == out) {
+        ErrorF("[xkb] Open xkbKeyMapBuf for writing failed\n");
+        return False;
+    }
+    ret = XkbWriteXKBKeymapForNames(out, names, xkb, want, need);
+    if (fclose(out) !=0)
+    {
+        ErrorF("[xkb] XkbWriteXKBKeymapForNames error, perhaps xkbKeyMapBuf is too small\n");
+        return False;
+    }
+#ifdef DEBUG
+    if (xkbDebugFlags) {
+       ErrorF("[xkb] XkbDDXCompileKeymapByNames compiling keymap:\n");
+       fputs(xkbKeyMapBuf, stderr);
+    }
+#endif
+    if (!ret) {
+        ErrorF("[xkb] Generating XKB Keymap failed, giving up compiling keymap\n");
+        return False;
+    }
+
+    DebugF("[xkb] computing SHA1 of keymap\n");
+    if (Success == Sha1Asc(sha1Asc, xkbKeyMapBuf)) {
+        snprintf(xkmfile, sizeof(xkmfile), "server-%s", sha1Asc);
+    }
+    else {
+        ErrorF("[xkb] Computing SHA1 of keymap failed, "
+               "using display name instead as xkm file name\n");
+        snprintf(xkmfile, sizeof(xkmfile), "server-%s", display);
+    }
 
     OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));
+    /* set nameRtrn, fail if it's too small */
+    if ((strlen(xkmfile)+1 > nameRtrnLen) && nameRtrn) {
+        ErrorF("[xkb] nameRtrn too small to hold xkmfile name\n");
+        return False;
+    }
+    strncpy(nameRtrn, xkmfile, nameRtrnLen);
+
+    /* if the xkm file already exists, reuse it */
+    canonicalXkmFileName = Xprintf("%s%s.xkm", xkm_output_dir, xkmfile);
+    if (access(canonicalXkmFileName, R_OK) == 0) {
+        /* yes, we can reuse the old xkm file */
+        LogMessage(X_INFO, "XKB: reuse xkmfile %s\n", canonicalXkmFileName);
+        result = True;
+        goto _ret;
+    }
+    LogMessage(X_INFO, "XKB: generating xkmfile %s\n", canonicalXkmFileName);
+
+    /* continue to call xkbcomp to compile the keymap. to avoid race
+       condition, we compile it to a tmpfile then rename it to
+       xkmfile */
 
 #ifdef WIN32
     strcpy(tmpname, Win32TempDir());
@@ -227,19 +320,30 @@ XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
 	}
     }
 
+    if ( (tmpXkmFile = tempnam(xkm_output_dir, NULL)) == NULL ) {
+        ErrorF("[xkb] Can't generate temp xkm file name");
+        result = False;
+        goto _ret;
+    }
+
     buf = Xprintf("\"%s%sxkbcomp\" -w %d %s -xkm \"%s\" "
-		  "-em1 %s -emp %s -eml %s \"%s%s.xkm\"",
+		  "-em1 %s -emp %s -eml %s \"%s\"",
 		  xkbbindir, xkbbindirsep,
 		  ( (xkbDebugFlags < 2) ? 1 :
 		    ((xkbDebugFlags > 10) ? 10 : (int)xkbDebugFlags) ),
-		  xkbbasedirflag, xkmfile,
+		  xkbbasedirflag, xkbfile,
 		  PRE_ERROR_MSG, ERROR_PREFIX, POST_ERROR_MSG1,
-		  xkm_output_dir, keymap);
+		  tmpXkmFile);
 
     if (xkbbasedirflag != emptystring) {
 	xfree(xkbbasedirflag);
     }
     
+    /* there's a potential race condition between calling tempnam()
+       and invoking xkbcomp to write the result file (potential temp
+       file name conflicts), but since xkbcomp is a standalone
+       program, we have to live with this */
+
 #ifndef WIN32
     out= Popen(buf,"w");
 #else
@@ -247,31 +351,43 @@ XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
 #endif
     
     if (out!=NULL) {
-#ifdef DEBUG
-    if (xkbDebugFlags) {
-       ErrorF("[xkb] XkbDDXCompileKeymapByNames compiling keymap:\n");
-       XkbWriteXKBKeymapForNames(stderr,names,xkb,want,need);
+        /* write XKBKeyMapBuf to xkbcomp */
+        if (EOF==fputs(xkbKeyMapBuf, out))
+        {
+            ErrorF("[xkb] Sending keymap to xkbcomp failed\n");
+            result = False;
+            goto _ret;
     }
-#endif
-	XkbWriteXKBKeymapForNames(out,names,xkb,want,need);
 #ifndef WIN32
 	if (Pclose(out)==0)
 #else
 	if (fclose(out)==0 && System(buf) >= 0)
 #endif
 	{
+        /* xkbcomp success */
             if (xkbDebugFlags)
                 DebugF("[xkb] xkb executes: %s\n",buf);
-	    if (nameRtrn) {
-		strncpy(nameRtrn,keymap,nameRtrnLen);
-		nameRtrn[nameRtrnLen-1]= '\0';
+
+            /* if canonicalXkmFileName already exists now, we simply
+               overwrite it, this is OK */
+            ret = rename(tmpXkmFile, canonicalXkmFileName);
+            if (0 != ret) {
+                ErrorF("[xkb] Can't rename %s to %s, error: %s\n",
+                       tmpXkmFile, canonicalXkmFileName,
+                       strerror(errno));
+
+                /* in case of error, don't unlink tmpXkmFile, leave it
+                   for debugging */
+
+                result = False;
+                goto _ret;
 	    }
-            if (buf != NULL)
-                xfree (buf);
-	    return True;
+
+            result = True;
+            goto _ret;
 	}
 	else
-	    LogMessage(X_ERROR, "Error compiling keymap (%s)\n", keymap);
+	    LogMessage(X_ERROR, "Error compiling keymap (%s)\n", xkbfile);
 #ifdef WIN32
         /* remove the temporary file */
         unlink(tmpname);
@@ -286,9 +402,17 @@ XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
     }
     if (nameRtrn)
 	nameRtrn[0]= '\0';
+    result = False;
+
+_ret:
+    if (tmpXkmFile)
+        free(tmpXkmFile);
+    if (canonicalXkmFileName)
+        xfree(canonicalXkmFileName);
     if (buf != NULL)
         xfree (buf);
-    return False;
+
+    return result;
 }
 
 static FILE *
@@ -372,7 +496,6 @@ unsigned	missing;
 	DebugF("Loaded XKB keymap %s, defined=0x%x\n",fileName,(*xkbRtrn)->defined);
     }
     fclose(file);
-    (void) unlink (fileName);
     return (need|want)&(~missing);
 }
 
diff --git a/xkb/xkbUtils.c b/xkb/xkbUtils.c
index 75e243c..30ec438 100644
--- a/xkb/xkbUtils.c
+++ b/xkb/xkbUtils.c
@@ -753,7 +753,7 @@ XkbSrvLedInfoPtr	sli;
     if (cause!=NULL) {
 	xkbControlsNotify cn;
 	cn.numGroups= ctrls->num_groups;
-	cn.changedControls|= XkbControlsEnabledMask;
+	cn.changedControls= XkbControlsEnabledMask;
 	cn.enabledControls= ctrls->enabled_ctrls;
 	cn.enabledControlChanges= (ctrls->enabled_ctrls^old);
 	cn.keycode= cause->kc;
