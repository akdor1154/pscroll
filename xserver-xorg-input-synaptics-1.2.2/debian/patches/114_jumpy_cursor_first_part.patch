diff -Nurp xserver-xorg-input-synaptics.orig/include/synaptics-properties.h xserver-xorg-input-synaptics/include/synaptics-properties.h
--- xserver-xorg-input-synaptics.orig/include/synaptics-properties.h	2009-12-08 11:16:01.123175000 +0100
+++ xserver-xorg-input-synaptics/include/synaptics-properties.h	2009-12-08 11:20:59.551925185 +0100
@@ -155,4 +155,7 @@
 /* 32 bit, 4 values, left, right, top, bottom */
 #define SYNAPTICS_PROP_AREA "Synaptics Area"
 
+/* 32 bit */
+#define SYNAPTICS_PROP_JUMPYCURSOR_THRESHOLD "Synaptics Jumpy Cursor Threshold"
+
 #endif /* _SYNAPTICS_PROPERTIES_H_ */
diff -Nurp xserver-xorg-input-synaptics.orig/man/synaptics.man xserver-xorg-input-synaptics/man/synaptics.man
--- xserver-xorg-input-synaptics.orig/man/synaptics.man	2009-12-08 11:16:01.127175000 +0100
+++ xserver-xorg-input-synaptics/man/synaptics.man	2009-12-08 11:20:59.551925185 +0100
@@ -509,6 +509,14 @@ Ignore movements, scrolling and tapping 
 The option is disabled by default and can be enabled by setting the
 AreaBottomEdge option to any integer value other than zero. Property: "Synaptics Area"
 .
+.TP
+.BI "Option \*qJumpyCursorThreshold\*q \*q" integer \*q
+Set the threshold above which movement events are ignored on single-touch touchpads.
+.
+The option is disabled by default and can be enabled by setting the
+JumpyCursorThreshold option to any integer value other than zero. Property: "Synaptics 
+Jumpy Cursor Threshold"
+.
 .LP
 A tap event happens when the finger is touched and released in a time
 interval shorter than MaxTapTime, and the touch and release
@@ -870,6 +878,14 @@ right button, two-finger detection, thre
 .BI "Synaptics Pad Resolution"
 32 bit unsigned, 2 values (read-only), vertical, horizontal in units/millimeter.
 
+.TP 7
+.BI "Synaptics Jumpy Cursor Threshold"
+The Synaptics Jumpy Cursor Threshold parameter is used to suppress movements (which
+take place in 20 milliseconds or less) whose covered distance is greater than or
+equal to the threshold on single-touch touchpads. This property is disabled by default.
+
+32 bit, 1 value. 0 disables the property.
+
 .SH "NOTES"
 There is an example hal policy file in
 .I ${sourcecode}/fdi/11-x11-synaptics.fdi
diff -Nurp xserver-xorg-input-synaptics.orig/src/properties.c xserver-xorg-input-synaptics/src/properties.c
--- xserver-xorg-input-synaptics.orig/src/properties.c	2009-12-08 11:16:01.127175000 +0100
+++ xserver-xorg-input-synaptics/src/properties.c	2009-12-08 11:32:28.907425148 +0100
@@ -84,6 +84,7 @@ Atom prop_gestures              = 0;
 Atom prop_capabilities          = 0;
 Atom prop_resolution            = 0;
 Atom prop_area                  = 0;
+Atom prop_jumpycursor_threshold = 0;
 
 static Atom
 InitAtom(DeviceIntPtr dev, char *name, int format, int nvalues, int *values)
@@ -274,6 +275,8 @@ InitDeviceProperties(LocalDevicePtr loca
     values[2] = para->area_top_edge;
     values[3] = para->area_bottom_edge;
     prop_area = InitAtom(local->dev, SYNAPTICS_PROP_AREA, 32, 4, values);
+
+    prop_jumpycursor_threshold = InitAtom(local->dev, SYNAPTICS_PROP_JUMPYCURSOR_THRESHOLD, 32, 1, &para->jumpycursor_threshold);
 }
 
 int
@@ -642,6 +645,12 @@ SetProperty(DeviceIntPtr dev, Atom prope
         para->area_right_edge  = area[1];
         para->area_top_edge    = area[2];
         para->area_bottom_edge = area[3];
+    } else if (property == prop_jumpycursor_threshold)
+    {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->jumpycursor_threshold = *(INT32*)prop->data;
     }
 
     return Success;
diff -Nurp xserver-xorg-input-synaptics.orig/src/synaptics.c xserver-xorg-input-synaptics/src/synaptics.c
--- xserver-xorg-input-synaptics.orig/src/synaptics.c	2009-12-08 11:20:15.851926000 +0100
+++ xserver-xorg-input-synaptics/src/synaptics.c	2009-12-08 11:38:38.156675531 +0100
@@ -132,6 +132,9 @@ static void ReadDevDimensions(LocalDevic
 static void ScaleCoordinates(SynapticsPrivate *priv, struct SynapticsHwState *hw);
 static void CalculateScalingCoeffs(SynapticsPrivate *priv);
 
+int old_time_millis = 0;
+Bool was_time_skipped = FALSE;
+
 #if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
 void InitDeviceProperties(LocalDevicePtr local);
 int SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
@@ -534,6 +537,7 @@ static void set_default_parameters(Local
     pars->tap_and_drag_gesture = xf86SetBoolOption(opts, "TapAndDragGesture", TRUE);
     pars->resolution_horiz = xf86SetIntOption(opts, "HorizResolution", horizResolution);
     pars->resolution_vert = xf86SetIntOption(opts, "VertResolution", vertResolution);
+    pars->jumpycursor_threshold = xf86SetIntOption(opts, "JumpyCursorThreshold", 0);
 
     /* Warn about (and fix) incorrectly configured TopEdge/BottomEdge parameters */
     if (pars->top_edge > pars->bottom_edge) {
@@ -1573,11 +1577,12 @@ HandleTapProcessing(SynapticsPrivate *pr
 #define HIST(a) (priv->move_hist[((priv->hist_index - (a) + SYNAPTICS_MOVE_HISTORY) % SYNAPTICS_MOVE_HISTORY)])
 
 static void
-store_history(SynapticsPrivate *priv, int x, int y, unsigned int millis)
+store_history(SynapticsPrivate *priv, int x, int y, int num_fingers, unsigned int millis)
 {
     int idx = (priv->hist_index + 1) % SYNAPTICS_MOVE_HISTORY;
     priv->move_hist[idx].x = x;
     priv->move_hist[idx].y = y;
+    priv->move_hist[idx].num_fingers = num_fingers;
     priv->move_hist[idx].millis = millis;
     priv->hist_index = idx;
 }
@@ -1726,11 +1731,70 @@ ComputeDeltas(SynapticsPrivate *priv, st
 	dy += hw->guest_dy;
     }
 
+    /* Handle quirks here */
+    if (dx || dy) {
+        /* Work around issues caused by two fingers on multi-touch
+         * models
+         */
+        if (priv->has_double) {
+            if ((hw->numFingers < 2) &&
+                ((HIST(0).num_fingers >= 2) || (HIST(1).num_fingers >= 2) ||
+                 (HIST(2).num_fingers >= 2) || (HIST(3).num_fingers >= 2) )) {
+                dx = dy = 0;
+            }
+            old_time_millis = hw->millis;
+        }
+        /* Work around issues caused by two fingers on single-touch
+         * models
+         */
+        else {
+            /* If para->jumpycursor_threshold <= 0, quirks are not
+             * available
+             */
+            if (para->jumpycursor_threshold <= 0)
+                goto post_quirks;
+
+            int elapsed_time = hw->millis - HIST(0).millis;
+
+            /* Ignore deltas as they couldn't possibly happen in so little time */
+            if (elapsed_time <= 20 && (abs(dx) >= para->jumpycursor_threshold || abs(dy) >= para->jumpycursor_threshold)) {
+                dx = dy = 0.0;
+                was_time_skipped = FALSE;
+            }
+            /* A comparison between the timestamp in priv->move_hist and hw->millis shows
+             * that something went wrong and that an event was skipped, hence the deltas
+             * are wrong.
+             * Let's ignore the deltas and append the skipped event to priv->move_hist
+             * otherwise the next deltas will be wrong too.
+             */
+            else if (old_time_millis > 0 && (HIST(0).millis != old_time_millis)) {
+                dx = dy = 0.0;
+                was_time_skipped = TRUE;
+            }
+            /* Something went wrong and an event was previously skipped, hence these deltas
+             * are wrong.
+             * Let's ignore the deltas and set was_time_skipped to FALSE as the next deltas
+             * should be good.
+             */
+            else {
+                if (was_time_skipped) {
+                    dx = 0.0;
+                    dy = 0.0;
+                }
+                was_time_skipped = FALSE;
+            }
+
+            old_time_millis = hw->millis;
+        }
+
+    }
+post_quirks:
+
     *dxP = dx;
     *dyP = dy;
 
     /* generate a history of the absolute positions */
-    store_history(priv, hw->x, hw->y, hw->millis);
+    store_history(priv, hw->x, hw->y, hw->numFingers, hw->millis);
 
     return delay;
 }
diff -Nurp xserver-xorg-input-synaptics.orig/src/synapticsstr.h xserver-xorg-input-synaptics/src/synapticsstr.h
--- xserver-xorg-input-synaptics.orig/src/synapticsstr.h	2009-12-08 11:16:01.127175000 +0100
+++ xserver-xorg-input-synaptics/src/synapticsstr.h	2009-12-08 11:29:47.238925256 +0100
@@ -33,6 +33,7 @@
 typedef struct _SynapticsMoveHist
 {
     int x, y;
+    int num_fingers;
     int millis;
 } SynapticsMoveHistRec;
 
@@ -149,6 +150,7 @@ typedef struct _SynapticsParameters
     unsigned int resolution_horiz;          /* horizontal resolution of touchpad in units/mm */
     unsigned int resolution_vert;           /* vertical resolution of touchpad in units/mm */
     int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge; /* area coordinates absolute */
+    int jumpycursor_threshold;      /* jumpy cursor threshold */
 } SynapticsParameters;
 
 
diff -Nurp xserver-xorg-input-synaptics.orig/tools/synclient.c xserver-xorg-input-synaptics/tools/synclient.c
--- xserver-xorg-input-synaptics.orig/tools/synclient.c	2009-12-08 11:16:01.127175000 +0100
+++ xserver-xorg-input-synaptics/tools/synclient.c	2009-12-08 11:40:34.679925145 +0100
@@ -143,6 +143,7 @@ static struct Parameter params[] = {
     {"AreaRightEdge",         PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	1},
     {"AreaTopEdge",           PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	2},
     {"AreaBottomEdge",        PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	3},
+    {"JumpyCursorThreshold",  PT_INT,    0, 1000,  SYNAPTICS_PROP_JUMPYCURSOR_THRESHOLD,	32,	0},
     { NULL, 0, 0, 0, 0 }
 };
 
